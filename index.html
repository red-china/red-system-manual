<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
<title>Red/System语言规范</title>
<link media="screen" href="light.css" type="text/css" rel="stylesheet">
</head>
<body bgcolor="white">
<table width="800" cellpadding="4" cellspacing="0" border="0">
<tbody><tr height="10"><td align="right">
	<a href="http://static.red-lang.org/red-system-specs-light.html" target="_blank">原文</a>
</td></tr>
<tr><td class="cnt"><h1>Red/System语言规范</h1>
<blockquote><b>
作者: Nenad Rakocevic<br>日期: 01/05/2017<br>修订号: 52<br>类型: 参考文档<br>主页: <a href="http://www.red-lang.org/">red-lang.org</a>
</b></blockquote>
<h2>目录:</h2>
<a class="toc1" href="#section-1">1. 概要</a><br>
<a class="toc1" href="#section-2">2. 语法</a><br>
<a class="toc2" href="#section-2.1">2.1 分隔符</a><br>
<a class="toc2" href="#section-2.2">2.2 范式无关语法</a><br>
<a class="toc2" href="#section-2.3">2.3 注释</a><br>
<a class="toc1" href="#section-3">3. 变量</a><br>
<a class="toc2" href="#section-3.1">3.1 设置值</a><br>
<a class="toc2" href="#section-3.2">3.2 获取值</a><br>
<a class="toc2" href="#section-3.3">3.3 类型声明</a><br>
<a class="toc1" href="#section-4">4. 数据类型</a><br>
<a class="toc2" href="#section-4.1">4.1 整数</a><br>
<a class="toc2" href="#section-4.2">4.2 字节</a><br>
<a class="toc2" href="#section-4.3">4.3 浮点数</a><br>
<a class="toc2" href="#section-4.4">4.4 32位浮点数</a><br>
<a class="toc2" href="#section-4.5">4.5 逻辑值</a><br>
<a class="toc2" href="#section-4.6">4.6 C语言字符串</a><br>
<a class="toc2" href="#section-4.7">4.7 结构体</a><br>
<a class="toc2" href="#section-4.8">4.8 指针</a><br>
<a class="toc2" href="#section-4.9">4.9 类型转换</a><br>
<a class="toc2" href="#section-4.10">4.10 大小</a><br>
<a class="toc1" href="#section-5">5. 表达式</a><br>
<a class="toc2" href="#section-5.1">5.1 一般性规则</a><br>
<a class="toc2" href="#section-5.2">5.2 执行顺序规则</a><br>
<a class="toc1" href="#section-6">6. 函数</a><br>
<a class="toc2" href="#section-6.1">6.1 声明</a><br>
<a class="toc2" href="#section-6.2">6.2 返回值</a><br>
<a class="toc2" href="#section-6.3">6.3 属性</a><br>
<a class="toc2" href="#section-6.4">6.4 类型推断</a><br>
<a class="toc2" href="#section-6.5">6.5 函数调用</a><br>
<a class="toc2" href="#section-6.6">6.6 函数指针</a><br>
<a class="toc2" href="#section-6.7">6.7 提前退出</a><br>
<a class="toc1" href="#section-7">7. 作用域</a><br>
<a class="toc2" href="#section-7.1">7.1 全局上下文</a><br>
<a class="toc2" href="#section-7.2">7.2 函数上下文</a><br>
<a class="toc2" href="#section-7.3">7.3 命名空间</a><br>
<a class="toc1" href="#section-8">8. 中缀操作符</a><br>
<a class="toc2" href="#section-8.1">8.1 数学操作符</a><br>
<a class="toc2" href="#section-8.2">8.2 移位操作符</a><br>
<a class="toc2" href="#section-8.3">8.3 位操作符</a><br>
<a class="toc2" href="#section-8.4">8.4 比较操作符</a><br>
<a class="toc1" href="#section-9">9. 控制流函数</a><br>
<a class="toc2" href="#section-9.1">9.1 if</a><br>
<a class="toc2" href="#section-9.2">9.2 either</a><br>
<a class="toc2" href="#section-9.3">9.3 loop</a><br>
<a class="toc2" href="#section-9.4">9.4 until</a><br>
<a class="toc2" href="#section-9.5">9.5 while</a><br>
<a class="toc2" href="#section-9.6">9.6 break</a><br>
<a class="toc2" href="#section-9.7">9.7 continue</a><br>
<a class="toc2" href="#section-9.8">9.8 any</a><br>
<a class="toc2" href="#section-9.9">9.9 all</a><br>
<a class="toc2" href="#section-9.10">9.10 case</a><br>
<a class="toc2" href="#section-9.11">9.11 switch</a><br>
<a class="toc1" href="#section-10">10. 异常</a><br>
<a class="toc2" href="#section-10.1">10.1 throw</a><br>
<a class="toc2" href="#section-10.2">10.2 catch</a><br>
<a class="toc2" href="#section-10.3">10.3 异常值</a><br>
<a class="toc1" href="#section-11">11. 栈函数</a><br>
<a class="toc2" href="#section-11.1">11.1 push</a><br>
<a class="toc2" href="#section-11.2">11.2 pop</a><br>
<a class="toc1" href="#section-12">12. 调试函数</a><br>
<a class="toc2" href="#section-12.1">12.1 assert</a><br>
<a class="toc1" href="#section-13">13. 系统结构体</a><br>
<a class="toc2" href="#section-13.1">13.1 args-count</a><br>
<a class="toc2" href="#section-13.2">13.2 args-list</a><br>
<a class="toc2" href="#section-13.3">13.3 env-vars</a><br>
<a class="toc2" href="#section-13.4">13.4 stack/top</a><br>
<a class="toc2" href="#section-13.5">13.5 stack/frame</a><br>
<a class="toc2" href="#section-13.6">13.6 stack/align</a><br>
<a class="toc2" href="#section-13.7">13.7 stack/allocate</a><br>
<a class="toc2" href="#section-13.8">13.8 stack/free</a><br>
<a class="toc2" href="#section-13.9">13.9 pc</a><br>
<a class="toc2" href="#section-13.10">13.10 cpu</a><br>
<a class="toc2" href="#section-13.11">13.11 cpu/overflow?</a><br>
<a class="toc2" href="#section-13.12">13.12 fpu/type</a><br>
<a class="toc2" href="#section-13.13">13.13 fpu/option</a><br>
<a class="toc2" href="#section-13.14">13.14 fpu/mask</a><br>
<a class="toc2" href="#section-13.15">13.15 fpu/control-word</a><br>
<a class="toc2" href="#section-13.16">13.16 fpu/epsilon</a><br>
<a class="toc2" href="#section-13.17">13.17 fpu/update</a><br>
<a class="toc2" href="#section-13.18">13.18 fpu/init</a><br>
<a class="toc2" href="#section-13.19">13.19 alias</a><br>
<a class="toc1" href="#section-14">14. 编译器指令</a><br>
<a class="toc1" href="#section-15">15. 导入外部库</a><br>
<a class="toc2" href="#section-15.1">15.1 #import</a><br>
<a class="toc2" href="#section-15.2">15.2 #syscall</a><br>
<a class="toc1" href="#section-16">16. 预处理指令</a><br>
<a class="toc2" href="#section-16.1">16.1 #define</a><br>
<a class="toc2" href="#section-16.2">16.2 #enum</a><br>
<a class="toc2" href="#section-16.3">16.3 #include</a><br>
<a class="toc2" href="#section-16.4">16.4 #if</a><br>
<a class="toc2" href="#section-16.5">16.5 #either</a><br>
<a class="toc2" href="#section-16.6">16.6 #switch</a><br>
<a class="toc2" href="#section-16.7">16.7 #verbose</a><br>
<a class="toc2" href="#section-16.8">16.8 #call</a><br>
<a class="toc2" href="#section-16.9">16.9 #export</a><br>
<a class="toc2" href="#section-16.10">16.10 #u16</a><br>
<a class="toc1" href="#section-17">17. 代码组织</a><br>
<a class="toc2" href="#section-17.1">17.1 源文件后缀</a><br>
<a class="toc2" href="#section-17.2">17.2 文件头</a><br>
<a class="toc2" href="#section-17.3">17.3 代码布局</a><br>
<a class="toc2" href="#section-17.4">17.4 编码指南</a><br>
<a class="toc2" href="#section-17.5">17.5 共享库程序</a><br>
<a class="toc2" href="#section-17.6">17.6 驱动程序</a><br>
<a class="toc1" href="#section-18">18. 保留关键字</a><br>
<a class="toc1" href="#section-19">19. 未来的改进</a><br>
<a class="toc2" href="#section-19.1">19.1 变量</a><br>
<a class="toc2" href="#section-19.2">19.2 指针</a><br>
<a class="toc2" href="#section-19.3">19.3 结构体</a><br>
<a class="toc2" href="#section-19.4">19.4 C语言字符串</a><br>
<a class="toc2" href="#section-19.5">19.5 逻辑值</a><br>
<a class="toc2" href="#section-19.6">19.6 整数</a><br>
<a class="toc2" href="#section-19.7">19.7 函数</a><br>
<a class="toc2" href="#section-19.8">19.8 新的数据类型</a><br>
<a class="toc2" href="#section-19.9">19.9 新的函数</a><br>
<a class="toc2" href="#section-19.10">19.10 其它</a><br>
<a class="toc1" href="#section-20">20. 文档历史记录</a><br>
<h2 id="section-1">1. 概要</h2>
<blockquote>
<p>Red/System是Red语言的一种方言(<a href="http://en.wikipedia.org/wiki/Domain-specific_language" target="_new">DSL</a>)。它旨在提供以下特性：</p>
<ul>
<li>底层系统编程能力</li>
<li>用作构建Red运行时底层库的工具</li>
<li>用作链接代码并产生可执行文件的工具</li>
</ul>
<p>Red/System可以看作是拥有内存指针和一些基本且有限的数据类型的和C语言同一级别的语言。</p>
<p><u>注意</u>：Red/System当前提供了一套完整的从源码构建出可执行文件的工具链。这是Red/System存在于Red中的临时状态，因此它也被嵌入在Red脚本中。</p>
</blockquote>
<h2 id="section-2">2. 语法</h2>
<blockquote>
<p>Red的语法和REBOL语言的语法基本上相同，因为用在启动阶段的词法分析器(<a href="http://www.rebol.com/docs/words/wload.html" target="_new">LOAD</a>)当前是就是用REBOL语言写的。REBOL语言的语法既没有正式的规范也没有完整的文档，仅仅是一个粗略的描述。不过这都不是事儿，拿来开发项目完全足够了。详情请参考：</p>
<ul>
<li><a href="http://www.rebol.com/docs/core23/rebolcore-3.html" target="_new">http://www.rebol.com/docs/core23/rebolcore-3.html</a> (这个页面的表格中有一处错误，所有字面量的第一个引号后面都缺少(^)符号)</li>
<li><a href="http://www.rebol.com/r3/docs/guide/code-syntax.html" target="_new">http://www.rebol.com/r3/docs/guide/code-syntax.html</a></li>
</ul>
<p>在实现Red的语言层面之后，我们将会提供一份完整的Red和Red/System的语法规范。</p>
<p>目前，Red/System使用的是8-bit字符编码(ASCII)。一旦在Red的语言层面实现了对Unicode的支持，Red/System也会切换到UTF-8编码。</p>
<p>以下是一些语言语法的具体部分：</p>
</blockquote>
<h3 id="section-2.1">2.1 分隔符</h3>
<blockquote>
<p>字符串分隔符：双引号</p>
<pre>"this is a string"

{This is
 a multiline
 string.
}
</pre>
<p>代码块分隔符：方括号</p>
<pre>if a &gt; 0 [print "TRUE"]

either a &gt; 0 [print "TRUE"][print "FALSE"]

while [a &gt; 0][print "loop" a: a - 1]
</pre>
<p>路径分隔符：斜线(表示层级关系)</p>
<pre>s: declare struct! [i [integer!] b [byte!]]
s/i: 123
s/b: #"A"
</pre>
</blockquote>
<h3 id="section-2.2">2.2 范式无关语法</h3>
<blockquote>
<p>Red/System(以及Red)继承了REBOL语言的范式无关语法。只有句法约束是放在以空格分隔的记号和一对分隔符之间。</p>
<p>有效的例子代码：</p>
<pre>while [a &gt; 0][print "loop" a: a - 1]

while [a &gt; 0]
    [print "loop" a: a - 1]

while [
   a &gt; 0
][
   print "loop"
   a: a - 1
]
</pre>
<p>现在代码风格还不确定，我们目前是遵循标准的REBOL风格。</p>
</blockquote>
<h3 id="section-2.3">2.3 注释</h3>
<blockquote>
<p>单行注释：</p>
<pre>;this is a commented line

print "hello world"    ; this is another comment
</pre>
<p>多行注释：</p>
<pre>comment {
    This is a
    multiline
    comment
}
</pre>
<p>使用规定：</p>
<ul>
<li>单行注释允许出现在代码中的任何地方</li>
<li>多行注释也可以出现在代码中的任何地方，但是不允许出现在表达式中间。例如：</li>
</ul>
<pre>a: 1 + comment {5} 4   ; this will produce a compilation error
</pre>
</blockquote>
<h2 id="section-3">3. 变量</h2>
<blockquote>
<p>变量是用于表示内存位置的一个标签。标签(现在叫做标识符(<b>identifiers</b>))是由一系列不包含任何空白(空格、换行或制表符)的可打印字符组成的。可打印字符是除了以下(用作分隔符或一些数据类型字面量)这些之外任何编码范围在20h-7Eh的单字节范围内的字符：</p>
<pre>[ ] { } " ( ) / \ @ # $ % ^ , : ; &lt; &gt;
</pre>
<p>第一个字符有严格的限制，以下是严禁出现在第一个字符，但是允许出现在其它位置的：</p>
<pre>0 1 2 3 4 5 6 7 8 9 '
</pre>
<p>另外还有个为了避免编译器误认为十六进制是一个变量名的限制：以2个A-F字母开头，加上4或8个A-F和0-9字符，然后以h结尾的变量名，都是不允许的。</p>
<p>所有的标识符(变量和函数名)都是<u>大小写不敏感</u>的。</p>
<p></p><fieldset class="fset"><legend>Unicode支持</legend>
<p>如语法部分所言，Unicode支持目前在启动阶段无效，它在Red层才有效，所以一旦Red/System用Red重写，Red/System会继承此特性。</p>
</fieldset>
</blockquote>
<h3 id="section-3.1">3.1 设置值</h3>
<blockquote>
<p>变量可以保存任何有效的数据类型值。它可以是一个实数(比如integer!或pointer!)或一个到真实值的一个引用。为了给变量赋值，在标识符后面写一个分号即可。</p>
<pre>foo: 123
bar: "hello"
</pre>
<p></p><fieldset class="fset"><legend>多次赋值</legend>
<p>多次赋值，例如 a: b: 123，当前在Red/System中还没有支持。这种特性将会在将来的某个时间点添加，也许在用Red重写Red/System的时候。</p>
</fieldset>
</blockquote>
<h3 id="section-3.2">3.2 获取值</h3>
<blockquote>
<p>直接用变量名，不用任何其它的装饰就能得到它的值，或者将它作为函数参数：</p>
<pre>bar: "hello"
print bar
</pre>
<p>将会输出：</p>
<pre>hello
</pre>
</blockquote>
<h3 id="section-3.3">3.3 类型声明</h3>
<blockquote>
<p>变量全都拥有类型。它不需要在使用前声明类型，但是初始化的时候需要。函数局部变量也要求声明类型，但是如果变量已经被相应地初始化了，那么类型声明部分可以跳过。例如这些：</p>
<pre>foo: 123
bar: "hello"
size: length? bar
id: GetProcessID                       ;-- 'GetProcessID would return an integer!

compute: func [
   a [integer!]
   return: [integer!]
   /local c                            ;-- 'c is declared without a type
][
   c: 1                                ;-- inferred type is integer!
   a + c
]
</pre>
<p>都是有效的用法。</p>
<p>初始化必须在代码的最顶层完成，尝试在一个代码块中初始化将会造成编译时错误。</p>
<pre>foo: 123                               ;-- valid initialization

if a &lt; b [foo: 123]                    ;-- invalid initialization
</pre>
<p><u>注意</u>：函数的body block也被看作是最顶层。</p>
<p>允许的变量类型为以下：</p>
<ul>
<li>integer!</li>
<li>byte!</li>
<li>float!</li>
<li>float32!</li>
<li>logic!</li>
<li>c-string!</li>
<li>struct!</li>
<li>pointer!</li>
</ul>
</blockquote>
<h2 id="section-4">4. Datatypes</h2>
<blockquote>
<p>All the following datatypes are <a href="http://en.wikipedia.org/wiki/First-class_citizen">first-class citizens</a> of Red/System language.</p>
</blockquote>
<h3 id="section-4.1">4.1 Integer!</h3>
<blockquote>
<h4 id="section-4.1.1">4.1.1 Literal format</h4>
<pre>decimal form          :  1234

decimal negative form : -1234

hexadecimal form      :  04D2h
</pre>
<p>The integer! datatype represents natural and negative natural numbers. The memory size of an integer is 32 bits, so the range of supported numbers is :</p>
<pre>-2147483648 to 2147483647
</pre>
<p><b>Hexadecimal format</b></p>
<p>Hexadecimal integer representation is mostly used to represent memory addresses or binary data for bitwise operations. As for character, all hexadecimal literals found in sources are converted to their integer decimal value during lexical analysis. Allowed range is:</p>
<pre>00000000h to FFFFFFFFh
</pre>
<p>Hex letters have to be written in <b>uppercase</b> and only 2, 4 and 8 characters are allowed (prefixing with leading zeros is allowed).</p>
<p></p><fieldset class="fset"><legend>Hex literal form design decision</legend>
<p>The 0x prefix is often used to mark a literal hexadecimal value. It could have been used in Red/System too if the &lt;number&gt;x&lt;number&gt; literal form wasn't reserved in Red for the pair! datatype. As Red/System is a dialect of Red, it has to use the same representation for hex values, so <b>&lt;hexa&gt;h</b> was chosen instead.</p>
</fieldset>
</blockquote>
<h3 id="section-4.2">4.2 Byte!</h3>
<blockquote>
<p>The byte! datatype's purpose is to represent unsigned integers in the 0-255 range.</p>
<h4 id="section-4.2.1">4.2.1 Syntax</h4>
<pre>#"&lt;character&gt;"
#"^&lt;character&gt;"
#"^(hexadecimal)"
#"^(name)"
</pre>
<p>Examples:</p>
<pre>#"a"
#"A"
#"5"
#"^A"
#"^(1A)"
#"^(back)"
</pre>
<p>See <a href="http://www.rebol.com/docs/core23/rebolcore-16.html#section-3.1" target="_new">http://www.rebol.com/docs/core23/rebolcore-16.html#section-3.1</a> for a more complete description of this format.</p>
<h4 id="section-4.2.2">4.2.2 Casting</h4>
<p>Casting is allowed to some extent (see section "4.9 Type Casting").</p>
<pre>foo: as integer! #"a"                  ;-- foo holds 97

bar: as byte! foo                      ;-- bar holds #"a"
</pre>
<p><u>Note</u>: trying to cast an integer value greater than 255 to a byte! will result in a data loss or data corruption. <i>(The handling of this case might be changed in future revisions)</i></p>
</blockquote>
<h3 id="section-4.3">4.3 Float!</h3>
<blockquote>
<p>The float! datatype represents an IEEE-754 double precision floating point number. Float! memory size is 64-bit.</p>
<p><u>Note</u>: <b>float64!</b> can be used as an alias to <b>float!</b>.</p>
<h4 id="section-4.3.1">4.3.1 Syntax</h4>
<pre>&lt;sign&gt;&lt;digits&gt;.&lt;digits&gt;
</pre>
<p>or using scientific notation:</p>
<pre>&lt;sign&gt;&lt;digits&gt;E&lt;exponent&gt;
&lt;sign&gt;&lt;digits&gt;.&lt;digits&gt;E&lt;exponent&gt;
</pre>
<p>where:</p>
<pre>&lt;sign&gt;     : an optional + or - symbol
&lt;digits&gt;   : one or more digits
&lt;exponent&gt; : a positive or negative integer
</pre>
<p>Examples:</p>
<pre>0.0
1.0
-12345.6789
3.14159265358979
-1E3
+1.23456E-265
</pre>
<p>A maximum of 16 digits are accepted for literal float! values. If more are specified, they will be dropped.</p>
<p><i>For more information on double precision floating point numbers, see <a href="http://en.wikipedia.org/wiki/Double-precision_floating-point_format">Wikipedia</a></i>.</p>
<h4 id="section-4.3.2">4.3.2 Casting</h4>
<p>It is allowed to apply a type casting transformation on a float! value to convert it to a float32! value.</p>
<p>Examples:</p>
<pre>pi: 3.14159265358979
pi-32: as float32! pi
print pi-32
</pre>
<p>will output</p>
<pre>3.1415927
</pre>
<h4 id="section-4.3.3">4.3.3 Math operations</h4>
<p>All Red/System math operators (+, -, *, /, //, %) are supported. The default rounding method on results is "rounding to nearest". Both operands need to be of float! types (no implicit casting).</p>
<p>The modulo (//) and remainder (%) operators give the same results when used on float! values.</p>
</blockquote>
<h3 id="section-4.4">4.4 Float32!</h3>
<blockquote>
<p>The float32! datatype represents an IEEE-754 single precision floating point number. Float32! memory size is 32-bit.</p>
<p></p><fieldset class="fset"><legend>Float32! purpose</legend>
<p>The reason for having a single precision floating point type is for making the interfacing with popular libraries straightforward. For pure Red/System programs, <b>float!</b> should be the default choice.</p>
</fieldset>
<h4 id="section-4.4.1">4.4.1 Syntax</h4>
<p>There is no literal form for float32! datatype values. To load a float32! constant, the method consists of providing a float! literal and prefixing it with a type casting to float32!.</p>
<p>Example:</p>
<pre>pi32: as float32! 3.1415927
</pre>
<p><i>For more information on single precision floating point numbers, see <a href="http://en.wikipedia.org/wiki/Single-precision_floating-point_format">Wikipedia</a></i>.</p>
<h4 id="section-4.4.2">4.4.2 Casting</h4>
<p>It is allowed to apply a type casting transformation on a float32! value to convert it to a float! value. Type casting to integer! is also allowed mainly for bits manipulation purpose (this is not a float32! number to integer! number conversion).</p>
<p>Examples:</p>
<pre>s: as float32! 3.1415927
print [
   as float! s lf
   as integer! s
]
</pre>
<p>will output</p>
<pre>3.14159270000000
1518260631
</pre>
<h4 id="section-4.4.3">4.4.3 Math operations</h4>
<p>All Red/System math operators (+, -, *, /, //, %) are supported. The default rounding method on results is "rounding to nearest". Both operands need to be of float32! types (no implicit casting).</p>
<p>The modulo (//) and remainder (%) operators give the same results when used on float32! values.</p>
</blockquote>
<h3 id="section-4.5">4.5 Logic!</h3>
<blockquote>
<p>The logic! datatype represents boolean values: <b>TRUE</b> and <b>FALSE</b>. Logic variables are initialized using a literal logic value or the result of a conditional expression.</p>
<p>As a first class datatype, you can pass logic values and variables as function arguments or use them as function's return value.</p>
<h4 id="section-4.5.1">4.5.1 Literal format</h4>
<pre>true
false
</pre>
<p>Using a literal to initialize a logic variable:</p>
<pre>foo: true
either foo [print "true"][print "false"]
</pre>
<p>will output:</p>
<pre>true
</pre>
<p>Using a conditional expression to initialize a logic variable:</p>
<pre>bar: 2 &gt; 5
either bar [print "true"][print "false"]
</pre>
<p>will output:</p>
<pre>false
</pre>
</blockquote>
<h3 id="section-4.6">4.6 C-string!</h3>
<blockquote>
<p>A c-string! value is a sequence of non-null bytes terminated by a null byte. A c-string variable holds the memory address of the first byte of the c-string, so it can be viewed as an implicit pointer to a variable of the byte! datatype. A c-string having a null character as first byte is an empty c-string.</p>
<h4 id="section-4.6.1">4.6.1 Syntax</h4>
<p>Literal c-strings are defined using double quotes delimiters or a pair of matching curly braces:</p>
<pre>foo: "I am a c-string"
bar: {I am
  a multiline
  c-string
}
</pre>
<p></p><fieldset class="fset"><legend>C-string null byte ending</legend>
<p>You don't have to add a null byte to literal c-strings. It is added automatically during compilation.</p>
</fieldset>
<h4 id="section-4.6.2">4.6.2 C-string length</h4>
<p>It is possible to retrieve the number of bytes (<b>excluding the null</b> end marker) in a c-string at runtime using the LENGTH? function:</p>
<pre>a: length? "Hello"                     ;-- here length? will return 5
</pre>
<p></p><fieldset class="fset"><legend>Length? vs Size?</legend>
<p>Do not confuse the <b>length?</b> function with the <b>size?</b> function. <b>Size?</b> function will return the number of bytes in the c-string, including the ending null byte.</p>
</fieldset>
<h4 id="section-4.6.3">4.6.3 C-string arithmetic</h4>
<p>It is possible to apply some simple math operations on c-string variables like additions and subtractions. C-string address would be increased or decreased by the integer argument.</p>
<p>Syntax</p>
<pre>&lt;c-string&gt; + &lt;n&gt;
&lt;c-string&gt; - &lt;n&gt;

&lt;c-string&gt; : c-string variable
&lt;n&gt;        : expression resulting in an integer! value
</pre>
<p>Example:</p>
<pre>s: "hello"                             ;-- let's suppose s points to address 40000000h

s: s + 1                               ;-- now s points to address 40000001h
print s                                ;-- "ello" would be printed
s: s + 1                               ;-- now s points to address 40000002h   
print s                                ;-- "llo" would be printed
</pre>
<h4 id="section-4.6.4">4.6.4 Accessing bytes</h4>
<p>It is possible to access individual bytes in a c-string using path notation:</p>
<pre>&lt;c-string&gt;/integer!                    ;-- literal integer index provided
&lt;c-string&gt;/&lt;index&gt;                     ;-- index provided by a variable

&lt;c-string&gt; : a c-string variable
&lt;index&gt;    : an integer variable
</pre>
<p>The returned value will be of the type <b>byte!</b>.</p>
<p>Examples:</p>
<pre>foo: "I am a c-string"
foo/1  =&gt;  #"I"                        ;-- byte! value (73)
foo/2  =&gt;  #" "                        ;-- byte! value (32)
...
foo/15 =&gt; #"g"                         ;-- byte! value (103)
foo/16 =&gt; #"^(00)"                     ;-- byte! value (0) (end marker)
</pre>
<p></p><fieldset class="fset"><legend>Important notes</legend>
<ul>
<li>In contrast to the C language, indexes in Red/System are <b>one-based</b>.</li>
<li>The behaviour of path with an index out of bounds is not yet defined. It is better to avoid it.</li>
</ul>
</fieldset>
<p>Example of a variable used as index:</p>
<pre>c: 4
foo/c  =&gt; #"m"                         ;-- byte! value (109)
</pre>
<p>A simple way to traverse a c-string would be:</p>
<pre>foo: "I am a c-string"
bar: foo

until [
     print bar/1                   
     bar: bar + 1
     bar/1 = null-byte
]
</pre>
<p>will output:</p>
<pre>I am a c-string
</pre>
<p>Similarly, it is also possible to modify the c-string's bytes using path notation with an ending colon:</p>
<pre>&lt;c-string&gt;/integer!:   &lt;value&gt;         ;-- literal integer index provided
&lt;c-string&gt;/&lt;index&gt;:    &lt;value&gt;         ;-- index provided by a variable

&lt;c-string&gt; : a c-string variable
&lt;index&gt;    : an integer variable
&lt;value&gt;    : a byte! value
</pre>
<p>For example:</p>
<pre>foo: "I am a c-string"
foo/3: #"-"
c: 4
foo/c: #"-"
print foo
</pre>
<p>will output</p>
<pre>I -- a c-string
</pre>
</blockquote>
<h3 id="section-4.7">4.7 Struct!</h3>
<blockquote>
<p>Struct! datatype is roughly equivalent to C struct type. It is a record of one or several values, each value having its own datatype. A struct variable holds the memory address of a struct value.</p>
<p><u>Implementation note</u>: Struct! values members are <u>padded</u> in memory in order to preserve optimal alignment for each target (for example, it is aligned to 4 bytes for IA32 target). <b>Size?</b> function will return the size of the struct! value in memory including the padding bytes.</p>
<h4 id="section-4.7.1">4.7.1 Declaration</h4>
<p>Declaring a struct! value is achieved by using the DECLARE STRUCT! sequence followed by a specification block. That block defines struct! value members using pairs of name and datatype definition.</p>
<pre>declare struct! [
   &lt;member&gt; [&lt;datatype&gt;]
   ...
]
&lt;member&gt;   : a valid identifier
&lt;datatype&gt; : integer! | byte! | pointer! [integer! | byte!] | logic! |
             float! | float32! | c-string! | struct! [&lt;members&gt;] |
             struct! [&lt;members&gt;] value | function! [&lt;spec&gt;]
</pre>
<p>The returned value of DECLARE STRUCT! is the memory address of the newly created struct! value.</p>
<p><u>Note</u>: Struct members are all initialized to 0 when a new literal struct! is declared.</p>
<h4 id="section-4.7.2">4.7.2 Usage</h4>
<pre>s: declare struct! [
   a   [integer!]
   b   [c-string!]
   c   [struct! [d [integer!] e [float!]]]
]
</pre>
<p>In this example, the struct value has 3 members: a, b, c, each with a different datatype. The c member is a struct! value <b>pointer</b>, it needs to be assigned to a struct value to be used. So a correct initialization for the c member would be:</p>
<pre>s/c: declare struct! [d [integer!]]
</pre>
<p>It is possible to nest struct values (and not just pointers to struct values) by adding the <b>value</b> keyword at the tail of a nested struct type specification:</p>
<pre>s2: declare struct! [
   a   [integer!]
   b   [c-string!]
   c   [struct! [d [integer!] e [float!]] value]
]
</pre>
<p>In this case, the nested struct c storage space is reserved when allocating the space for the parent struct s2. The size of struct s2 is 20 bytes, while the size of s is 12 bytes.</p>
<p>Struct pointers and struct values can be arbitrarily nested and mixed together.</p>
<h4 id="section-4.7.3">4.7.3 Accessing members</h4>
<p>Member access is achieved using path notation. Syntax is:</p>
<pre>&lt;struct&gt;/&lt;member&gt;                      ;-- read access
&lt;struct&gt;/&lt;member&gt;: &lt;value&gt;             ;-- write access

&lt;struct&gt;  : a valid struct variable
&lt;member&gt;  : a valid member identifier in &lt;struct&gt;
&lt;value&gt;   : a value of same datatype as &lt;member&gt;
</pre>
<p>From last example, that would give:</p>
<pre>foo: s/a                               ;-- reading member 'a in struct 's
s/a: 123                               ;-- writing 123 in member 'a in struct 's
s/b: "hello"
bar: s/c/d                             ;-- deep read/write access is also possible
</pre>
<p><u>Note</u>: Accessing a function! pointer member will result in dereferencing the pointer.</p>
<p>It is also possible to acquire a pointer on a struct member using the get-path notation:</p>
<pre>:&lt;struct&gt;/&lt;member&gt;

&lt;struct&gt;  : a valid struct variable
&lt;member&gt;  : a valid member identifier in &lt;struct&gt;
</pre>
<p>The returned type is always `pointer! [integer!]` in such case. It can be freely type-casted to other pointer types.</p>
<pre>p: :s/a
p/value                               ;-- returns the value of s/a
p/value: 456                          ;-- sets a new value in s/a
</pre>
<h4 id="section-4.7.4">4.7.4 Struct arithmetic</h4>
<p>It is possible to apply some simple math operations on struct variables, like additions and subtractions. Struct address would be increased or decreased by the size of the pointed struct value multiplied by the integer argument.</p>
<p><b>Syntax</b></p>
<pre>&lt;struct&gt; + &lt;n&gt;
&lt;struct&gt; - &lt;n&gt;

&lt;struct&gt;   : struct variable
&lt;n&gt;        : integer value
</pre>
<p><b>Examples</b></p>
<pre>p: declare struct! [                   ;-- let suppose p = 40000000h
   a [integer!]
   b [pointer! [integer!]]
]                                      ;-- struct memory size would be 8 bytes
p: p + 1                               ;-- now p = 40000008h
</pre>
<p><u>Note</u>: The struct value size is target and alignment dependent. In the above example, it is supposed to run on a 32-bit system with a struct alignment to 4 bytes.</p>
<h4 id="section-4.7.5">4.7.5 Aliases</h4>
<p>Struct! values definitions tend to be quite long, so in some cases, when struct! definitions are required to be inserted in other struct! definitions or in functions specification block, it is possible to use an alias name to reference a struct! definition through the source code. It also allows the self-referencing case to be quite simply solved.</p>
<p><u>Notes</u>:</p>
<ul>
<li>An alias is not a value, it doesn't take any space in memory, it can be seen as a <i>virtual datatype</i>. So, by convention, alias names should end with an exclamation mark, in order to distinguish them more easily from variables in the source code.</li>
<li>Aliased names live in their own namespace, so they cannot interfere with variable names.</li>
</ul>
<p>Aliasing syntax:</p>
<pre>&lt;name&gt;: alias struct! [
   &lt;member&gt; [&lt;datatype&gt;]
   ...
]
&lt;name&gt;     : the name to use as alias
&lt;member&gt;   : a valid identifier
&lt;datatype&gt; : integer! | byte! | pointer! [integer! | byte!] | logic! |
             float! | float32! | c-string! | struct! [&lt;members&gt;] |
             struct! [&lt;members&gt;] value | function! [&lt;spec&gt;]
</pre>
<p>Struct value declaration using an aliased definition:</p>
<pre>&lt;variable&gt;: declare &lt;alias&gt;

&lt;variable&gt;  : a struct variable
&lt;alias&gt;     : a previously declared alias name
</pre>
<p>Struct usage example:</p>
<pre>book!: alias struct! [                 ;-- defines a new aliased type
   title       [c-string!]
   author      [c-string!]
   year        [integer!]
   last-book   [book!]                 ;-- self-referenced definition
]

gift: declare struct! [
   first  [book!]                      ;-- reference to a book! struct
   second [book!]                      ;-- reference to a book! struct
]

gift/first: declare book!              ;-- book! struct allocation

gift/first/title:  "Contact"
gift/first/author: "Carl Sagan"
gift/first/year:   1985

gift2: declare struct! [
   first  [book! value]                ;-- inlined book! struct value
   second [book! value]                ;-- inlined book! struct value
]
</pre>
</blockquote>
<h3 id="section-4.8">4.8 Pointer!</h3>
<blockquote>
<p>The purpose of the pointer datatype is to hold the memory address of another value. A pointer value is defined by the pointed value address and datatype. As c-string! and struct! are already implicit pointers, the only pointed datatypes allowed are integer!, float!, float32! and byte! (logic! pointer is not needed).</p>
<p>Byte! pointers are equivalent to c-string! references, the difference lies only in the interpretation of the pointed values. Byte! pointer is meant to point to a stream of byte without a specified bound, while c-string! references an array of bytes terminated by a null byte.</p>
<p><u>Implementation note</u>: The memory size of a pointer is 4 bytes on 32-bit systems (and 8 bytes on 64-bit systems).</p>
<h4 id="section-4.8.1">4.8.1 Literal format</h4>
<p>New pointers value can be created using the following syntax:</p>
<pre>declare pointer! [&lt;datatype&gt;]

&lt;datatype&gt;: integer! | byte! | float! | float32!
</pre>
<p></p><fieldset class="fset"><legend>Possible syntactic sugar</legend>
<p>The &amp; symbol used in previous revisions of this document has been removed due to the new limited pointer! datatype usage. It could be reintroduced again in the future if required.</p>
</fieldset>
<p>Examples:</p>
<pre>foo: declare pointer! [integer!]       ;-- equivalent to C's: int *foo;
bar: declare pointer! [byte!]          ;-- equivalent to C's: char *bar;
baz: declare pointer! [float!]         ;-- equivalent to C's: double *baz;
</pre>
<p></p><fieldset class="fset"><legend>Pointer value initialization</legend>
<p>Do not assume any default value for a pointer value until it is initialized properly. In the current implementation, global pointer variables are set to <b>null</b> by default while local pointer variables default value is undefined. This might change in the future to adopt a default value more suitable for debugging (like 0BADBAD0h or similar hex trick).</p>
</fieldset>
<h4 id="section-4.8.2">4.8.2 Declaration</h4>
<p>Pointer declaration is only required for arguments in functions' specification block. For local pointer variables, the datatype declaration can be omitted and left to the inferencer to guess. (See "Type inference" section)</p>
<pre>pointer! [&lt;datatype&gt;]

&lt;datatype&gt;: integer! | byte! | float! | float32!
</pre>
<p>Global variables declaration examples (with C equivalents):</p>
<pre>p: declare pointer! [integer!]         ;-- int *p;
p: declare pointer! [byte!]            ;-- char *p;
p: declare pointer! [float!]           ;-- double *p;
</pre>
<p>Same with local variables declaration examples (with C equivalents):</p>
<pre>func [/local p [pointer! [integer!]]   ;-- int *p;
func [/local p [pointer! [byte!]]      ;-- char *p;
func [/local p [pointer! [float!]]     ;-- double *p;
</pre>
<p>Example of inferred pointer variable type:</p>
<pre>foo: func [
   a [struct! [count [integer!]]]
   /local
       p [pointer! [integer!]]         ;-- explicit declaration
][
   foobar p                            ;-- foobar modifies p
   a/count: p/value
]

bar: func [
   a [struct! [count [integer!]]]
   /local p                            ;-- p datatype inferred
][
   p: declare pointer! [integer!]      ;-- p initialized (implicit declaration)
   foobar p
   a/count: p/value
]

bar2: func [
   a [struct! [count [integer!]]]
   /local p                            ;-- p datatype inferred
][
   p: GetPointer a                     ;-- datatype is guessed from return value
   foobar p
   a/count: p/value
]
</pre>
<h4 id="section-4.8.3">4.8.3 Dereferencing</h4>
<p>Dereferencing a pointer is the operation allowing access to the pointed value. In Red/System, it is achieved by adding a <b>/value</b> refinement to the pointer variable (called more generally "path notation"):</p>
<pre>&lt;pointer&gt;/value                        ;-- read access
&lt;pointer&gt;/value: &lt;value&gt;               ;-- write access

&lt;pointer&gt; : pointer variable
&lt;value&gt;   : a value of same type as in pointer's definition
</pre>
<p>Usage example</p>
<pre>p:   declare pointer! [integer!]       ;-- declare a pointer on an integer
bar: declare pointer! [integer!]       ;-- declare another pointer on an integer

p: as [pointer! [integer!]] 40000000h  ;-- type cast an integer! to a pointer!
p/value: 1234                          ;-- write 1234 at address 40000000h
foo: p/value                           ;-- read pointed value back
bar: p                                 ;-- assign pointer address to 'bar
</pre>
<p><u>Note</u>: Remember that a pointed value is undefined (can contain an arbitrary value) until you define it explicitly</p>
<h4 id="section-4.8.4">4.8.4 Pointer arithmetic</h4>
<p>It is possible to apply some simple math operations on pointers, like additions and subtractions (as in C). A pointer address will be increased or decreased by the memory size of the pointed value multiplied by the amount to respectively add or subtract.</p>
<pre>p: declare pointer! [integer!]         ;-- pointed value memory size is 4 bytes

p: as [pointer! [integer!]] 40000000h
p: p + 1                               ;-- p points now to 40000004h
p: p + 1                               ;-- p points now to 40000008h
q: declare pointer! [byte!]            ;-- pointed value memory size is 1 byte
q: as [pointer! [byte!]] 40000000h
q: q + 1                               ;-- p points now to 40000001h
q: q + 1                               ;-- p points now to 40000002h
</pre>
<p>Also, additions and subtractions between pointer addresses are allowed. The result value type is, as usual, the type of left operand.</p>
<pre>offset: p - q                          ;-- would store 6 in offset
                                       ;-- type of offset is pointer! [integer!]
</pre>
<h4 id="section-4.8.5">4.8.5 Pointer path notation</h4>
<p>It is possible to use path notation to simulate an array with indexed access. Both reading and writing are possible. Indexes are <b>one-based</b>.</p>
<p><b>Syntax</b></p>
<pre>&lt;pointer&gt;/&lt;integer&gt;                    ;-- literal integer index provided
&lt;pointer&gt;/&lt;index&gt;                      ;-- index provided by a variable

&lt;pointer&gt;  : a pointer variable
&lt;integer&gt;  : an integer literal value
&lt;index&gt;    : an integer variable
</pre>
<p>Examples:</p>
<pre>p: declare pointer! [integer!]

p: as [pointer! [integer!]] 40000000h
a: p/1                                 ;-- reads an integer! from 40000000h
p/2: a                                 ;-- writes the integer! to 40000004h
</pre>
<p>Integer variable can also be used as index:</p>
<pre>p: declare pointer! [integer!]

p: as [pointer! [integer!]] 40000000h
c: 2
p/c: 1234                              ;-- writes 1234 (4 bytes) at 40000004h
</pre>
<p><u>Note</u>: Pointer's <b>/value</b> notation is strictly equivalent to <b>/1</b>. The <b>/value</b> notation can be considered as syntactic sugar.</p>
<h4 id="section-4.8.6">4.8.6 Literal arrays</h4>
<p>A pointer can also point to a one-dimensional array of values literally specified.</p>
<p><b>Syntax</b></p>
<pre>&lt;variable&gt;: [&lt;items&gt;]

&lt;variable&gt; : a pointer of same type as the array items.
&lt;items&gt;    : is a non-empty list of integer!, byte!, float! literal values.
</pre>
<p>The array is statically allocated and can be accessed using pointer path notation or pointer arithmetic. The size of the array (in number of elements) is stored in a 32-bit word just preceding the beginning of the array.</p>
<p>Examples:</p>
<pre>list: [123 456 789]
probe list/0                           ;-- outputs 3
probe list/2                           ;-- outputs 456

s: [#"h" #"e" #"l" #"l" #"o"]
sz: as int-ptr! s
probe sz/0                             ;-- outputs 5
probe s/5                              ;-- outputs o
</pre>
<p><u>Note</u>: In this last example, this literal array is not equivalent to its c-string! counterpart "hello", as the literal array does not add a NUL value at tail of the sequence.</p>
<p></p><fieldset class="fset"><legend>Write access to arrays</legend>
<p>Currently literal arrays allow write access, but there is no bound checking as it is planned to be a feature of a future array! first-class datatype.</p>
</fieldset>
<h4 id="section-4.8.7">4.8.7 Null value</h4>
<p>A special <b>null</b> value is available to use for pointer! and other pointer-like (pass-by-reference) types (struct!, c-string!) and pseudo-type function!. <b>Null</b> does not have a specific type, but can be used to replace any other pointer-like value. So, <b>null</b> cannot be used as initializing value for a global variable or a local variable that does not have an explicit type specification.</p>
<p><b>Null</b> is a first class value, so it can be assigned to a variable, passed as argument to a function or returned by a function.</p>
<p><u>Note</u>: It is not possible to explicitly cast <b>null</b> to a given type, only implicit type casting automatically done by the compiler is allowed.</p>
<p>Examples:</p>
<pre>a: declare pointer! [integer!]
a: null                                ;-- valid assignment, 'a type is defined
b: null                                ;-- invalid assignment, type of b cannot
                                       ;--  be deduced by the compiler

foo: func [s [c-string!] return: [c-string!]][
   if s = null [
       print "error"
       return null
   ]
   return uppercase s
]

b: foo "test"                          ;-- will set b to "TEST"
b: foo null                            ;-- will print "error" and set b to null
</pre>
<h4 id="section-4.8.8">4.8.8 C void pointer</h4>
<p>There is no specific support in Red/System for C-like void pointers. The official way is to use a pointer! [byte!] type to represent C void* pointers.</p>
<p>For pointers to c-string! or struct! variables, a pointer variable can be used then dereferenced and converted using type casting to the target type.</p>
<p>Example:</p>
<pre>p-buffer!: alias struct! [buffer [c-string!]]

set-hello: function [
   s [p-buffer!]
][
   s/buffer: "hello"
   s                                   ;-- equivalent to C's char **
]

foo: func [
   /local
       c [p-buffer!]
][
   c: declare p-buffer!
   set-hello c
   print c/buffer
]

foo                                    ;-- call foo function
</pre>
<p>would print</p>
<pre>hello
</pre>
<p></p><fieldset class="fset"><legend>Runtime macro byte-ptr!</legend>
<p>The runtime defines a byte-ptr! macro (just defined as: pointer! [byte!]) to be used as an equivalent to C void* for raw memory accesses.</p>
</fieldset>
<h4 id="section-4.8.9">4.8.9 Variable pointer</h4>
<p>It is possible to get a pointer on an existing variable for the following datatypes:</p>
<ul>
<li>integer!</li>
<li>byte!</li>
<li>float!</li>
<li>float32!</li>
</ul>
<p><b>Syntax</b></p>
<pre>:&lt;variable&gt;

&lt;variable&gt; : a variable name of allowed type.
</pre>
<p>This expression will return a pointer value which type depends on the variable type, so:</p>
<p></p><div align="center">
<table class="normal">
<tbody><tr>
<th>variable</th>
<th>:variable</th>
</tr><tr>
<td>integer!</td>
<td>pointer! [integer!]</td>
</tr><tr>
<td>byte!</td>
<td>pointer! [byte!]</td>
</tr><tr>
<td>float!</td>
<td>pointer! [float!]</td>
</tr><tr>
<td>float32!</td>
<td>pointer! [float32!]</td>
</tr>
</tbody></table>
</div><p></p>
<p>Example:</p>
<pre>s: declare pointer! [integer!]
a: 123
s: :a
print s/value       ;-- will output 123
</pre>
<p></p><fieldset class="fset"><legend>Pointer on local variable</legend>
<p>It is allowed to get a pointer on a local variable, however, <u>special attention</u> should be provided to avoid using such pointer once the function has returned, this would result in most cases in crashes caused by stack corruption!</p>
</fieldset>
</blockquote>
<h3 id="section-4.9">4.9 Type Casting</h3>
<blockquote>
<p>Casting is achieved using the <b>AS</b> keyword followed by the target type and the value to cast.</p>
<p>Type casting is possible between value of compatible types. Compatible types are defined in the following type casting reference matrix. A run-time type conversion might be generated for some types combinations.</p>
<p><u>Note</u>: Trying to assign a value to a variable of different type without a proper type casting, will result in a compilation error.</p>
<p><b>Syntax</b></p>
<pre>as &lt;new-type&gt; value
as [&lt;new-type&gt;] value                  ;-- alternative syntax

&lt;new-type&gt; : integer! | byte! |  logic! | c-string! | float! | float32! |
             pointer! [integer!] | struct! [&lt;members&gt;] |
             &lt;alias-name&gt;
</pre>
<p><u>Note</u>: Multiple nested type castings are not allowed and will raise a compilation error.</p>
<p>Example:</p>
<pre>foo: 0                                 ;-- foo is an integer variable
bar: declare pointer! [integer!]       ;-- bar is a pointer variable

foo: as integer! bar                   ;-- type casting
bar: as pointer! [integer!] foo
</pre>
<p><br> 
<b>Type casting reference matrix</b></p>
<p>Keep in mind that pointer!, c-string!, struct! and function! are passed by reference, so the casting below for these datatypes is applied on their memory address value.</p>
<p></p><div align="center">
<p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><table class="matrix">
<tbody><tr>
<th id="matrix-start">source&gt;&gt;</th>
<th>byte!</th>
<th>integer!</th>
<th>logic!</th>
<th>c-string!</th>
<th>pointer!</th>
<th>struct!</th>
<th>float!</th>
<th>float32!</th>
<th>function!</th>
</tr><tr>
<th>byte!</th>
<td class="warn">WARNING</td>
<td class="allow">as byte! ¹</td>
<td class="allow">true<span class="arrow">»</span>#"^(01)"<br>false<span class="arrow">»</span>#"^(00)"</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
</tr><tr>
<th>integer!</th>
<td class="allow">as integer!</td>
<td class="warn">WARNING</td>
<td class="allow">true<span class="arrow">»</span>1<br>false<span class="arrow">»</span>0</td>
<td class="allow">as integer!</td>
<td class="allow">as integer!</td>
<td class="allow">as integer!</td>
<td class="allow">to integer!</td>
<td class="allow">to integer!</td>
<td class="allow">as integer!</td>
</tr><tr>
<th>logic!</th>
<td class="allow">#"^(00)"<span class="arrow">»</span>false<br>else<span class="arrow">»</span>true</td>
<td class="allow">0<span class="arrow">»</span>false<br>else<span class="arrow">»</span>true</td>
<td class="warn">WARNING</td>
<td class="allow">null<span class="arrow">»</span>false<br>else<span class="arrow">»</span>true</td>
<td class="allow">null<span class="arrow">»</span>false<br>else<span class="arrow">»</span>true</td>
<td class="allow">null<span class="arrow">»</span>false<br>else<span class="arrow">»</span>true</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
</tr><tr>
<th>c-string!</th>
<td class="deny">ERROR</td>
<td class="allow">as c-string!</td>
<td class="deny">ERROR</td>
<td class="warn">WARNING</td>
<td class="allow">as c-string!</td>
<td class="allow">as c-string!</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
</tr><tr>
<th>pointer!</th>
<td class="deny">ERROR</td>
<td class="allow">as pointer!</td>
<td class="deny">ERROR</td>
<td class="allow">as pointer!</td>
<td class="warn">WARNING</td>
<td class="allow">as pointer!</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
</tr><tr>
<th>struct!</th>
<td class="deny">ERROR</td>
<td class="allow">as struct!</td>
<td class="deny">ERROR</td>
<td class="allow">as struct!</td>
<td class="allow">as struct!</td>
<td class="warn">WARNING</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
</tr>
<tr><th>float!</th>
<td class="deny">ERROR</td>
<td class="allow">as float!</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
<td class="warn">WARNING</td>
<td class="allow">as float! ²</td>
<td class="deny">ERROR</td>
</tr>
<tr><th>float32!</th>
<td class="deny">ERROR</td>
<td class="allow">as float32!</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
<td class="allow">as float32! ²</td>
<td class="warn">WARNING</td>
<td class="deny">ERROR</td>
</tr>
<tr><th>function!</th>
<td class="deny">ERROR</td>
<td class="allow">as function!</td>
<td class="deny">ERROR</td>
<td class="allow">as function!</td>
<td class="allow">as function!</td>
<td class="allow">as function!</td>
<td class="deny">ERROR</td>
<td class="deny">ERROR</td>
<td class="allow">as function!</td>
</tr>
</tbody></table>
</div><p></p>
<p>¹ Casting allowed, but integer values higher than 255 will be truncated, so beware!<br>
² A data modification can occur.<br></p>
</blockquote>
<h3 id="section-4.10">4.10 Size?</h3>
<blockquote>
<p><b>Syntax</b></p>
<pre>size? &lt;type&gt;
size? "&lt;string&gt;"

&lt;type&gt;     : an valid type name.
"&lt;string&gt;" : a c-string literal value.
</pre>
<p><b>Size?</b> returns the memory storage size in bytes required by a value of given type. When passed a c-string literal value, it will return the number of bytes in the c-string, including the ending null byte.</p>
<p><b>Example</b></p>
<pre>size? byte!                ;-- will return 1
size? integer!             ;-- will return 4
s!: alias struct! [
   a [integer!]
   b [float32!]
]
size? s!                   ;-- will return 8
</pre>
<p></p><fieldset class="fset"><legend>Dynamic string use cases</legend>
<p>Size? can only be used on a literal c-string, when only a c-string pointer is available use <b>length?</b> function.</p>
</fieldset>
</blockquote>
<h2 id="section-5">5. 表达式</h2>
<blockquote>
<p>表达式是组成Red/System程序的基本块。它们由以下方面组成：</p>
<ul>
<li>变量</li>
<li>字面值</li>
<li>函数调用</li>
<li>操作符调用</li>
<li>包裹在括号中的子表达式</li>
</ul>
</blockquote>
<h3 id="section-5.1">5.1 一般性规则</h3>
<blockquote>
<p>语法规则采用<a href="http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form" target="_new">BNF</a>格式约定, 除了省略号...，这意味着它是语言本身定义的。</p>
<pre>&lt;literal&gt;       ::= ... any valid Red/System literal value ...
&lt;variable&gt;      ::= ... any valid Red/System variable name ...
&lt;logic-call&gt;    ::= ... function call that returns a value of logic! type ...
&lt;func-call&gt;     ::= ... function call that returns a value ...
&lt;statement&gt;     ::= ... statement or function without return value...

&lt;logic-literal&gt; ::= "true" | "false"

&lt;math-op&gt;       ::= "+" | "-" | "*" | "/" | "//" | "%"
&lt;bitwise-op&gt;    ::= "and" | "or" | "xor"
&lt;comparison-op&gt; ::= "=" | "&lt;&gt;" | "&lt;" | "&lt;=" | "&gt;=" | "&gt;"
&lt;op&gt;            ::= &lt;math-op&gt; | &lt;bitwise-op&gt;

&lt;cond-expr&gt;     ::= &lt;value&gt; &lt;comparison-op&gt; &lt;expression&gt;
&lt;condition&gt;     ::= &lt;logic-literal&gt; | &lt;logic-call&gt; | &lt;cond-expr&gt;

&lt;all&gt;           ::= "ALL" "[" &lt;condition&gt;+ "]"
&lt;any&gt;           ::= "ANY" "[" &lt;condition&gt;+ "]" 
&lt;either&gt;        ::= "EITHER" &lt;condition&gt; "[" &lt;expression&gt;+ "]" "[" &lt;expression&gt;+ "]"
&lt;short-circuit&gt; ::= &lt;all&gt; | &lt;any&gt; | &lt;either&gt;

&lt;paren&gt;         ::= "(" &lt;expression&gt; ")"
&lt;value&gt;         ::= &lt;variable&gt; | &lt;literal&gt; | &lt;paren&gt; | "null"

&lt;infix&gt;         ::= &lt;value&gt; &lt;op&gt; &lt;expression&gt;
&lt;prefix&gt;        ::= &lt;func-call&gt; &lt;expression&gt;* | &lt;statement&gt; &lt;expression&gt;* 
&lt;call&gt;          ::= &lt;prefix&gt;+ | &lt;infix&gt; | &lt;cond-expr&gt;

&lt;expression&gt;    ::= &lt;call&gt; | &lt;value&gt; | &lt;short-circuit&gt;
</pre>
<p>表达式可以单独使用，或者在赋值语句之后使用，也可以作为另一个函数的参数使用(RETURN, IF或EITHER用作语句)。</p>
<p><u>注意</u>：EITHER只能在它后面的TRUE block和FALSE block是相同类型的情况下才可以用在表达式中。当在表达式中使用EITHER的时候，它相当于C语言的二元操作符(?)。</p>
<p><b>例子</b></p>
<pre>a: 123
foo a + 1
0 &lt; foo a + 1
any [(0 &lt; foo a + 1) a &gt; 0]

if any [(0 &lt; foo a + 1) a &gt; 0][print "ok"]

b: 1 + (2 * a - either zero? a [0][a + 100])
</pre>
</blockquote>
<h3 id="section-5.2">5.2 执行顺序规则</h3>
<blockquote>
<p>表达式是<b>从左到右</b>执行的。所以在Red中没有所谓的操作符优先级，前面的操作符总是比后面的操作符先执行。</p>
<p><b>例子</b></p>
<pre>1 + 2 * 3                              ;-- (1 + 2) * 3 returns 9
1 + 2 * 3 = 9                          ;-- ((1 + 2) * 3) = 9 returns TRUE
9 = 1 + 2 * 3                          ;-- ((9 = 1) + 2) * 3 raises an error!

1 + (2 * 3)                            ;-- 1 + (2 * 3) returns 7

foo 1 + 2                              ;-- foo (1 + 2)
1 + foo 2 * 3                          ;-- 1 + (foo (2 * 3))
</pre>
</blockquote>
<h2 id="section-6">6. Functions</h2>
<blockquote>
<p>Function definition and usage is pretty straightforward in Red/System. The function specification block contains all the definitions required by the function. This includes:</p>
<ul>
<li>calling arguments</li>
<li>optional returned value type</li>
<li>declaration of local variables</li>
<li>special attributes</li>
</ul>
<p></p><fieldset class="fset"><legend>Dialects</legend>
<p>The specification block is a Red/System dialect (DSL), so the words inside such block are interpreted specifically and relatively to this <i>function definition</i> dialect, they are not related or affected by other namespaces, like the global variables namespace. A consequence is that using the type names as variables names is possible, but not recommended in order to keep the source code more easily readable.</p>
</fieldset>
</blockquote>
<h3 id="section-6.1">6.1 Declaration</h3>
<blockquote>
<p><b>Syntax</b></p>
<pre>&lt;name&gt;: func | function [
   [&lt;attributes&gt;]                      ;-- optional part
   "&lt;function purpose&gt;"                ;-- optional doc-string
   &lt;argument&gt; [&lt;datatype&gt;]
    "&lt;argument description&gt;"           ;-- optional doc-string
   ...
   return: [&lt;datatype&gt;]                ;-- returned value type (optional part)
   "&lt;returned value description&gt;"      ;-- optional doc-string
   /local                              ;-- local variables (optional part)
   &lt;local&gt; [&lt;datatype&gt;]
   ...
][
   &lt;body&gt;
]

&lt;name&gt;       : function's name
&lt;attributes&gt; : special attributes
&lt;argument&gt;   : function's argument indentifier
&lt;datatype&gt;   : integer! | byte! | logic! | pointer! [integer! | byte!] |
               float! | float32! | c-string! | struct! [&lt;members&gt;] |
               struct! [&lt;members&gt;] value
&lt;local&gt;      : local variable
&lt;body&gt;       : function's body code
</pre>
<p>Doc-strings are just optional documentation that can be processed by any external tool, they have no runtime effect.</p>
<p></p><fieldset class="fset"><legend>Func vs Function</legend>
<p>Currently, <b>function</b> is a synonym for <b>func</b> in Red/System. In future, however, the behaviour of <b>function</b> in Red/System may be changed to match the behaviour of <b>function</b> in Red (i.e. all set-words are assumed locals).
Until this change has been decided, it may be wise to use the <b>func</b> keyword instead of <b>function</b> in Red/System code, particularly in cases where its use would be affected by such a change.</p>
</fieldset>
<p><b>Examples</b></p>
<pre>hello: func [][print "hello"]          ;-- no arguments, no locals, no return value

why?: func [return: [integer!]][42]    ;-- minimal function returning an integer

inc: func [                            ;-- increment an integer
   a [integer!]
   return: [integer!]
][
   a + 1                               ;-- last value is returned
]

percent?: func [                       ;-- return relative percentage of a / b
   a [integer!]
   b [integer!]
   return: [integer!]
   /local c                            ;-- declare local variables
][
   c: 100
   a * c / b
]
</pre>
<p></p><fieldset class="fset"><legend>Arguments passing</legend>
<p>In the current implementation, pointer!, integer!, byte!, float!, float32! and logic! arguments are passed by value, while c-string! and struct! arguments are passed by reference. Adding the `value` keyword after a struct! type specification, allows it to be passed by value (works also for returned value).</p>
</fieldset>
</blockquote>
<h3 id="section-6.2">6.2 Return value</h3>
<blockquote>
<p>Any function is able to return a value if necessary. This is trivially achieved as last expression in function's body will be automatically returned if:</p>
<ul>
<li>a RETURN: statement is present in function's spec block</li>
<li>the datatype of the function ending expression matches the one declared after the RETURN: statement</li>
</ul>
<p></p><fieldset class="fset"><legend>Returning struct by value</legend>
<p>By default, a struct is returned by reference. To return a struct by value, a `value` keyword needs to be added in the return specification block. For example:</p>
<pre>foo: func [return: [struct! [n [integer!] value]][...]
</pre>
<p>On the implementation side, Red/System follows the common ABI used by mainstream C compilers, so that passing structs to/from a C library should work fine.</p>
</fieldset>
</blockquote>
<h3 id="section-6.3">6.3 Attributes</h3>
<blockquote>
<p>It is possible to change how the function will behave at runtime using special attributes.</p>
<h4 id="section-6.3.1">6.3.1 Infix</h4>
<p>Allow the function to be called using an infix syntax. The function must take two arguments exactly or else a compilation error will be raised. Example:</p>
<pre>avg: func [[infix] a [integer!] b [integer!] return: [integer!]][
   (a + b) / 2
]

10 avg 6
</pre>
<p>will return:</p>
<pre>8
</pre>
<p><u>Notes</u>:</p>
<ul>
<li>When the <b>infix</b> syntax is used, the prefix syntax is still allowed, but it will work only if there is no value on the left side of the function call. Example:</li>
</ul>
<pre>func [return: [integer!]][
   avg 10 6                            ;-- will return 8 as well               
]                      

print "ok" avg 10 6                    ;-- will produce a compilation error
</pre>
<ul>
<li>The left-to-right evaluation rule applies also for user-defined infix functions, so:</li>
</ul>
<pre>10 avg 6 + 2                           ;-- avg is executed first, then +
</pre>
<p>is not equivalent to</p>
<pre>10 avg (6 + 2)                         ;-- + is executed first, then avg
</pre>
<h4 id="section-6.3.2">6.3.2 Cdecl</h4>
<p>Changes function's calling convention to C convention. This allows to safely pass a Red/System function as argument to imported C functions.</p>
<p>Example:</p>
<pre>#import [
    "foo.dll" cdecl [
        foo: "foo" [
            fun     [function! [a [integer!] b [integer!] return: [logic!]]]
            return: [integer!]
        ]
    ]
]

compare: func [
    [cdecl]                            ;-- use C calling convention
    left [integer!] right [integer!]
    return: [logic!]
][
    left &lt;= right
]

foo :compare                           ;-- pass the function pointer
</pre>
<p></p><fieldset class="fset"><legend>Stdcall support</legend>
<p>The <b>stdcall</b> attribute is also accepted (it is already the default calling convention in Red/System), but will have no effect for internal functions. Imported functions with such attribute will be compiled as callbacks, but in such case, the more explicit <b>callback</b> attribute should be used.</p>
</fieldset>
<h4 id="section-6.3.3">6.3.3 Callback</h4>
<p>The purpose of the <b>callback</b> attribute is to manually force a callback compilation mode for a function that the compiler failed to infer as a callback. It can be used as a more meaningful replacement for <b>stdcall</b> when used on Windows.</p>
<p>The compiler can correctly infer callbacks when a function pointer is passed as a get-word to an imported function call. Other cases of passing a Red/System function pointer cannot be properly detected as external callbacks.</p>
<p>For example, if Red/System function pointers are passed to an external API in an indirect way (filling an array or a structure), and those functions will be later called by the external code (OS or a library), the <b>callback</b> attribute *must* be used in order for correct code to be generated. Moreover, if the external caller is using C calling convention, then the additional <b>cdecl</b> is required.</p>
<h4 id="section-6.3.4">6.3.4 Variadic</h4>
<p>Triggers the variable argument mode for native or imported functions. A native function using this attribute must provide two arguments in its specification block:</p>
<ul>
<li>an integer variable for the arguments count</li>
<li>a pointer for the argument list (pointer! [integer!])</li>
</ul>
<p>An imported function just needs the attribute without any other arguments declaration.</p>
<p>Examples of definition:</p>
<pre>my-print: func [                      ;-- native function
  [variadic]
  count [integer!] list [int-ptr!]
][
  print ["count: " count lf]
  until [
      print [list/value lf]
      list: list + 1
      count: count - 1
      zero? count
  ]
]

#import [                              ;-- imported function
  LIBC-file cdecl [
      printf: "printf" [[variadic]]   ;-- no need to specify any argument here
  ]
]
</pre>
<p>Passing arguments to a variadic function is achieved by wrapping them in a block (squared brackets delimited list).</p>
<p>Example of calls:</p>
<pre>my-print ["hello" 123 "world"]
</pre>
<p>will output:</p>
<pre>count: 3
00402035                               ;-- pointer to "hello" c-string
0000007B                               ;-- 123 in hexadecimal
00402030                               ;-- pointer to "world" c-string
</pre>
<p>Calling an imported variadic function:</p>
<pre>printf ["%s %i %s" "hello" 123 "world"]
</pre>
<p>will output:</p>
<pre>hello 123 world
</pre>
<p></p><fieldset class="fset"><legend>Compatibity with other attributes</legend>
<p><b>Variadic</b> attribute can only be used alone or with the <b>cdecl</b> attribute.</p>
</fieldset>
<h4 id="section-6.3.5">6.3.5 Typed</h4>
<p>Triggers the variable argument mode with type information for native functions. <b>Typed</b> is similar to the <b>variadic</b> attribute. A native function using this attribute must provide two arguments in its specification block:</p>
<ul>
<li>an integer variable for the arguments count</li>
<li>a pointer for the argument records (using the <b>typed-value!</b> alias)</li>
</ul>
<p>The <b>typed-value!</b> alias is defined as</p>
<pre>typed-value!: alias struct! [
   value   [integer!]                  ;-- argument value or pointer
   type    [integer!]                  ;-- argument type   
]
</pre>
<p>Types are defined by the runtime as:</p>
<pre>#define type-logic!        1
#define type-integer!      2
#define type-byte!         3
#define type-float32!      4
#define type-float64!      5
#define type-float!        5
#define type-c-string!     6
#define type-byte-ptr!     7
#define type-int-ptr!      8
#define type-function!     9
#define type-struct!       1000
#define any-struct?        [1000 &lt;=]
#define alias?             [1001 &lt;=]
</pre>
<p>NULL value type ID is set by convention to type-int-ptr! ID (pointer! [integer!]).</p>
<p></p><fieldset class="fset"><legend>Typed and imported function</legend>
<p>It is possible to use <b>typed</b> attribute for an imported function, but it needs to meet the specific stack layout required by this attribute, so should probably be reserved only for imported function written in Red/System.</p>
</fieldset>
<p>Example of definition:</p>
<pre>vprint: func [
  [typed]
  count [integer!] list [typed-value!]
][
  print ["count: " count lf]
  until [
      print [list/value " : "]
      print [form-type list/type lf]  ;-- form-type converts a type ID to a c-string
      list: list + 1
      count: count - 1
      zero? count
  ]
]
</pre>
<p>Passing arguments to a variadic function with type information is achieved by wrapping them in a block (squared brackets).</p>
<p>Example of calls:</p>
<pre>vprint ["hello" 123 "world"]
</pre>
<p>will output:</p>
<pre>count: 3
00402043 : c-string!                   ;-- pointer to "hello" c-string
0000007B : integer!                    ;-- 123 in hexadecimal
0040203E : c-string!                   ;-- pointer to "world" c-string
</pre>
<p></p><fieldset class="fset"><legend>Compatibity with other attributes</legend>
<p><b>Typed</b> attribute can only be used on its own or with the <b>cdecl</b> attribute.</p>
</fieldset>
<h4 id="section-6.3.6">6.3.6 Custom</h4>
<p>It is sometimes desirable to have full control over the native stack layout of a function call, for example, when the function call needs to be dynamically constructed. The <b>custom</b> attribute allows you to manually <b>push</b> values on stack and still generate a correct function call with adequate stack cleanups. This is most useful with imported C functiosn that relies on <b>cdecl</b> convention, which requires the caller to clean-up the stack. The <b>custom</b> attribute will take care of it in a cross-platform way.</p>
<p>Example:</p>
<pre>foo: as function! [[custom]] &lt;imported-c-function&gt;
push 123
push 0
foo 2                               ;-- custom call with 2 arguments
</pre>
<p>A custom call requires an integer number that is consumed internally by the compiler. That integer specifies the number of arguments pushed on stack (which will be cleaned up when the call returns).</p>
<p></p><fieldset class="fset"><legend>Stack alignment</legend>
<p>Stack alignment constraints are not enforced by the <b>custom</b> attribute, so be sure to respect the platform-specific conventions with regards to alignment (mainly concerns macOS and ARM-based platforms). In order to do it in a clean and cross-platform way, use the <b>system/stack/align</b> call.</p>
</fieldset>
<h4 id="section-6.3.7">6.3.7 Catch</h4>
<p>Allows the function to catch runtime exceptions. The execution will resume inside the function just after the call where the exception occured. See <a href="http://static.red-lang.org/red-system-specs-light.html#section-6.8">Exceptions</a> section for more info.</p>
<p></p><fieldset class="fset"><legend>Compatibity with other attributes</legend>
<p><b>Catch</b> attribute can only be used on its own.</p>
</fieldset>
</blockquote>
<h3 id="section-6.4">6.4 Type inference</h3>
<blockquote>
<p>Functions offer a limited type inference possibility for local variables.</p>
<p>In practice, it means that it is allowed to omit a local variable type declaration as long as the variable is initialized properly.</p>
<p>Example:</p>
<pre>foo: func [
   a [integer!]
   return: [integer!]
   /local c                            ;-- omitted local variable type
][
   c: 10                               ;-- variable type is integer!
   a + c
]
</pre>
</blockquote>
<h3 id="section-6.5">6.5 Calling a function</h3>
<blockquote>
<p>Calling a function is achieved by writing its name followed by the required number of arguments.</p>
<p><i>(from the previous examples)</i></p>
<pre>hello                                  ;-- will print "hello" in the standard output

answer: why?                           ;-- will return 42 in variable 'answer

foo: 4
foo: inc foo                           ;-- foo holds 5 after the call to 'inc

bar: percent? 3 4                      ;-- bar holds 75
</pre>
<p>It is also possible to pipe several function calls together:</p>
<pre>foo: percent? 11 inc inc why?          ;-- will return 25 in foo
</pre>
</blockquote>
<h3 id="section-6.6">6.6 Function pointer</h3>
<blockquote>
<p>It is possible to obtain a function address to pass it, for example, as an argument to external calls with callbacks.</p>
<p><b>Syntax</b></p>
<pre>:&lt;function name&gt;
</pre>
<p>Example:</p>
<pre>progress: func [[cdecl] count [integer!]][
   print "."                           ;-- make the user see some progress
]

get-file "bigfile.avi" :progress       ;-- blocking job would call 'progress
                                       ;-- periodically
</pre>
<p>A function pointer can be assigned to a variable for later use or dereferencing. Such a variable cannot be passed as an argument to other functions, nor returned by a function. Function pointer pseudo-type is not a first class datatype.</p>
<p><u>Note</u>: Function address is returned as a function pointer pseudo-type, so it cannot be used as-is in expressions, but it can be safely casted to an integer! if required.</p>
<h4 id="section-6.6.1">6.6.1 Function definition alias</h4>
<p>In order to avoid repeating function specification, it is possible to define aliases by using ALIAS keyword.</p>
<p><b>Syntax</b></p>
<pre>&lt;name&gt;: alias function! [&lt;spec&gt;]

&lt;name&gt; : aliased identifier (by convention, a ! suffix is added)
&lt;spec&gt; : a function valid specification block
</pre>
<p>Example:</p>
<pre>foo!: alias function! [n [integer!] return: [integer!]]
bar: func [f [foo!]][...]
</pre>
<h4 id="section-6.6.2">6.6.2 Function dereferencing</h4>
<p>A function pointer can be dereferenced so that the function being pointed at will be called, like any other function. Correct number and type of arguments needs to be passed.</p>
<p>Example:</p>
<pre>foo!: alias function! [n [integer!] return: [integer!]]
inc: func [n [integer!] return: [integer!]][
   n + 1
]

bar: as foo! :inc

print bar 2                            ;-- will output 3
</pre>
<p>Alternatively, you can dereference a function! pointer stored as a struct member by just accessing it.</p>
<pre>s: declare struct! [
   inc [function! [n [integer!] return: [integer!]]]
]

s/inc: :inc

probe s/inc 3                          ;-- will output 4
</pre>
</blockquote>
<h3 id="section-6.7">6.7 Premature exiting</h3>
<blockquote>
<p>Exiting at a function's end is not always desirable. Sometimes, conditional premature exiting from the function is required. This can be done using EXIT or RETURN special keywords.</p>
<h4 id="section-6.7.1">6.7.1 Exit</h4>
<p>Immediatly quits the function.</p>
<pre>test: func [a [integer!]][
   if zero? a [exit]                   ;-- exit the function here if a = 0
   ...                                 ;-- if a &lt;&gt; 0, continue processing...
]
</pre>
<h4 id="section-6.7.2">6.7.2 Return</h4>
<p>Immediately quits the function and returns a value.</p>
<pre>test: func [
   a [integer!]
   return: [c-string!]
][
   if zero? a [
       return "Not allowed"            ;-- exit the function here if a = 0
   ]
   "ok"                                ;-- return "ok" if a &lt;&gt; 0
]
</pre>
</blockquote>
<h2 id="section-7">7. 作用域</h2>
<blockquote>
<p>在Red/System中，变量属于静态作用域。 源代码中声明变量的位置决定了它的作用域。</p>
</blockquote>
<h3 id="section-7.1">7.1 全局上下文</h3>
<blockquote>
<p>全局上下文定义为定义所有全局变量和函数的全局命名空间。 这个上下文是唯一的。 作为一个简单的规则，在函数中未声明的每个变量都是绑定到全局上下文的全局变量。</p>
<p>例子：</p>
<pre>foo: 123                               ;-- global variable

f: func [/local bar [integer!]][
   bar: 123                            ;-- locally scoped variable
]
</pre>
</blockquote>
<h3 id="section-7.2">7.2 函数上下文</h3>
<blockquote>
<p>每个定义的函数都有自己的局部上下文。 在函数的定义块中声明的变量是局部作用域的，不能在函数体内访问。 另一方面，全局变量可以被函数引用和修改。如果局部变量与全局变量具有相同的名称，则本地变量将在函数体中优先。 同义词全局变量的值不会受函数上下文中的局部重定义的影响。</p>
<p>例子：</p>
<pre>foo: 1                                 ;-- global variable
var: 2

f: func [
   return: [integer!]
   /local 
       bar [integer!]
][
   bar: 3
   foo + var + bar                     ;-- will return 6
]

f: func [
   return: [integer!]
   /local 
       bar [integer!]
       var [integer!]
][
   bar: 3
   var: 10                             ;-- 'var is a local variable here
   foo + var + bar                     ;-- will return 14
]
</pre>
<h4 id="section-7.2.1">7.2.1 USE关键字</h4>
<p>在函数体内部，使用USE关键字，可以创建任意的本地上下文，还有额外的局部变量：</p>
<p><b>语法</b></p>
<pre>use [&lt;spec&gt;][&lt;code&gt;]

&lt;spec&gt; : list of local variables followed by optional type specification
&lt;code&gt; : body block of code
</pre>
<p>这创建了一个局部上下文，其中新变量在body块中可用。 这些变量在离开body块时被释放。 使用函数规范中已经存在的变量名将导致编译错误。</p>
<p>规范块中列出的局部变量遵循与功能规范块中局部变量相同的语法。 变量名后跟一个类型说明，或让编译器推断类型（除了结构体的值，必须具有声明类型）。 USE创建的本地上下文也可以自由嵌套（只要不再使用外部本地上下文的变量名称）。</p>
<p>例子：</p>
<pre>f: func [
   /local 
       foo [integer!]
][
   foo: 1
   use [bar][
       bar: 2
       use [baz][
           baz: 3
           print foo + bar + baz       ;-- will output 6
       ]
   ]
]

f: func [
   cond    [logic!]
   return: [integer!]
   /local 
       bar [integer!]
][
   bar: 3
   if cond [
       use [var][
           var: 10                     ;-- 'var is a local variable here
           bar: var + bar              ;-- will return 14
       ]
   ]
   bar
]
</pre>
</blockquote>
<h3 id="section-7.3">7.3 命名空间</h3>
<blockquote>
<p>可以定义局部命名空间来提供能够封装源代码的局部上下文。</p>
<p><b>语法</b></p>
<pre>&lt;name&gt;: context [&lt;code&gt;]

&lt;name&gt; : namespace identifier
&lt;code&gt; : body block of code
</pre>
<p>包括功能定义在内的主体块中允许任何代码。 创建的所有变量和函数都将具有可以使用路径符号中的上下文名称前缀在本地或外部访问的本地名称：</p>
<pre>&lt;name&gt;/&lt;variable&gt;                       ;-- reading a variable from outside
&lt;name&gt;/&lt;variable&gt;:                      ;-- setting a variable from outside
&lt;name&gt;/&lt;func-name&gt;                      ;-- invoking a function from outside
</pre>
<p>以下元素受命名空间的影响，并在上下文正文块中声明时变为局部定义：</p>
<ul>
<li>variables</li>
<li>functions</li>
<li>imported functions</li>
<li>enumerations</li>
<li>aliases</li>
</ul>
<p>例子：</p>
<pre>b: 0
a: context [
   b: 123

   foo: func [/local b][
       b: 1
       print-line b
   ]

   print-line b                        ;-- will output 123
   foo                                 ;-- will output 1
]

print-line b                           ;-- will output 0
print-line a/b                         ;-- will output 123
a/foo                                  ;-- will output 1
a/b: a/b + 1
print-line a/b                         ;-- will output 124
</pre>
<p></p><fieldset class="fset"><legend>命名空间不是一个对象！</legend>
<p>即使它们看起来像对象，命名空间只在编译时存在，所以在运行时不能被操纵。</p>
</fieldset>
<h4 id="section-7.3.1">7.3.1 嵌套命名空间</h4>
<p>允许嵌套命名空间。 当冲突的名称用于变量或函数时，使用最近的定义。</p>
<p>例子：</p>
<pre>a: context [
   b: 123

   c: context [
       #enum colors! [red green blue]
       b: "hello"
       foo: func [][print-line b]
   ]

   print-line b                        ;-- will output 123
   c/foo                               ;-- will output hello
]

print-line a/b                         ;-- will output 123
a/c/foo                                ;-- will output hello
print-line a/c/b/2                     ;-- will output e
print-line a/c/blue                    ;-- will output 2
</pre>
<h4 id="section-7.3.2">7.3.2 全局上下文访问</h4>
<p>在嵌套命名空间内，为了在局部定义时从全局上下文中访问标识符，提供了一个特殊的虚拟路径来解决这种情况：</p>
<p><b>语法</b></p>
<pre>system/words/&lt;name&gt;                    ;-- calling a function, reading a variable
system/words/&lt;name&gt;:                   ;-- setting a variable

&lt;name&gt; : identifer or access path
</pre>
<p>例子：</p>
<pre>b: 123
a: context [
   b: 0
   print-line system/words/b           ;-- will output 123
]
</pre>
<p>任何全局上下文标识符都可以这样检索。</p>
<h4 id="section-7.3.3">7.3.3 WITH关键字</h4>
<p>为了限制源代码冗长度，如果源代码包含在具有</b>with<b>的块中，则可以省略命名空间前缀。</p>
<p><b>语法</b></p>
<pre>with &lt;name&gt;    [&lt;code&gt;]
with [&lt;names&gt;] [&lt;code&gt;]                ;-- alternative syntax for multiple names

&lt;name&gt;  : namespace identifier
&lt;names&gt; : list of namespace identifiers
&lt;code&gt;  : body block of code
</pre>
<p><u>注意</u>：如果指定了多个命名空间，并且如果它们共享相同的标识符，则最后定义的命名空间（从编译器的角度来看）优先。</p>
<p>例子：</p>
<pre>a: context [b: 0]
c: context [b: 1 d: 123]

with a [
   print-line b                        ;-- will output 0
   print-line a/b                      ;-- will output 0
]

with [a c][
   print-line d                        ;-- will output 123
   print-line b                        ;-- will output 1 ('c is defined after 'a)
]
</pre>
</blockquote>
<h2 id="section-8">8. 中缀操作符</h2>
<blockquote>
<p>中缀操作符带有两个参数，且位于它们之间。</p>
</blockquote>
<h3 id="section-8.1">8.1 数学操作符</h3>
<blockquote>
<p>以下数学运算适用于整数或浮点值。 当操作导致超出内存存储限制时，<i>行为待定义</i>。</p>
<p><b>加法</b>：+</p>
<pre>value1 + value2
</pre>
<p><b>减法</b>：-</p>
<pre>value1 - value2
</pre>
<p><b>乘法</b>：*</p>
<pre>value1 * value2
</pre>
<p><b>除法</b>：/</p>
<pre>value1 / value2
</pre>
<p><b>求余</b>：%</p>
<pre>value1 % value2
</pre>
<p>注意：如果除数为负，余数将为负数。 与REBOL中的C或//操作符相同。 有关float运算符的特定行为，请参见float类型部分。</p>
<p><b>求模</b>：//</p>
<pre>value1 // value2
</pre>
<p>注意：总是返回一个正数结果。 与REBOL中的模数函数相同。 有关float运算符的特定行为，请参见float类型部分。</p>
<p>此处</p>
<pre>value1 : an expression returning an integer!
value2 : expression of same (or compatible) datatype as &lt;value1&gt;
</pre>
<p>数学运算符的结果值类型是左参数的类型（隐式类型转换在需要时运行）。</p>
<p><u>注意：</u> 对于+和 - 运算符，一个pointer!，struct!或c-string!值可以用于两个参数，也可以作为第一个参数使用整数表达式作为第二个参数（参见“指针算术”）。</p>
</blockquote>
<h3 id="section-8.2">8.2 移位操作符</h3>
<blockquote>
<p><b>有符号左移</b>：&lt;&lt;</p>
<pre>value1 &lt;&lt; value2
</pre>
<p><b>有符号右移</b>：&gt;&gt;</p>
<pre>value1 &gt;&gt; value2
</pre>
<p><b>无符号右移</b>：&gt;&gt;&gt;</p>
<pre>value1 &gt;&gt;&gt; value2
</pre>
<p>此处</p>
<pre>value1 : an expression returning an integer! or byte!
value2 : integer! expression restricted to 0-31 range only.
</pre>
<p><u>注意</u>：没有无符号左移运算符，因为它与有符号左移运算符相同。</p>
</blockquote>
<h3 id="section-8.3">8.3 按位操作符</h3>
<blockquote>
<p><b>按位OR</b>: or</p>
<pre>value1 or value2
</pre>
<p><b>按位XOR</b>: xor</p>
<pre>value1 xor value2
</pre>
<p><b>按位AND</b>: and</p>
<pre>value1 and value2
</pre>
<p><b>按位/逻辑NOT</b>: not</p>
<pre>not value1
</pre>
<p>此处</p>
<pre>value1 : an expression returning an integer!, byte! or logic!
value2 : expression of same datatype as &lt;value1&gt;
</pre>
<p><u>注意</u>：逻辑NOT将返回与逻辑参数（TRUE&lt;=&gt;FALSE）的相反，而按位NOT将对整数参数应用补码。</p>
</blockquote>
<h3 id="section-8.4">8.4 比较操作符</h3>
<blockquote>
<p>只有在允许条件的情况下才能使用这些操作符。 有关使用条件的功能列表，请参阅“控制流程功能”一节。</p>
<p><b>相等</b>: =</p>
<pre>value1 = value2
</pre>
<p><b>不等于</b>: &lt;&gt;</p>
<pre>value1 &lt;&gt; value2
</pre>
<p><b>大于</b>: &gt;</p>
<pre>value1 &gt; value2
</pre>
<p><b>小于</b>: &lt;</p>
<pre>value1 &lt; value2
</pre>
<p><b>大于等于</b>: &gt;=</p>
<pre>value1 &gt;= value2
</pre>
<p><b>小于等于</b>: &lt;=</p>
<pre>value1 &lt;= value2
</pre>
<p>此处</p>
<pre>value1 : an expression returning a integer!, byte!, float!, float32!, 
         c-string!, pointer! or struct!

value2 : expression of same datatype as &lt;value1&gt;
</pre>
<p><u>注意</u>：</p>
<ul>
<li>=和&lt;&gt;也可以用于比较logic!值。</li>
<li>对于c-string!, pointer!和struct!, 仅仅比较引用，而不是比较指向的值。</li>
</ul>
</blockquote>
<h2 id="section-9">9. Control flow functions</h2>
<blockquote>
</blockquote>
<h3 id="section-9.1">9.1 if</h3>
<blockquote>
<p>Execute a block of code if a given condition is true. IF does not return any value, so it cannot be used in an expression.</p>
<p><b>Syntax</b></p>
<pre>if &lt;condition&gt; [&lt;code&gt;]

&lt;condition&gt; : a conditional expression
&lt;code&gt;      : code to execute if the condition is true
</pre>
<p><b>Example</b></p>
<pre>if a &lt; 0 [print "a is negative"]
</pre>
</blockquote>
<h3 id="section-9.2">9.2 either</h3>
<blockquote>
<p>Execute a block of code if a given condition is true, else execute an alternative block of code. If last expressions in both blocks have the same type, EITHER can be used inside an expression.</p>
<p><b>Syntax</b></p>
<pre>either &lt;condition&gt; [&lt;code&gt;][&lt;alternative&gt;]

&lt;condition&gt;   : a conditional expression
&lt;code&gt;        : code to execute if the condition is true
&lt;alternative&gt; : code to execute if the condition is false
</pre>
<p><b>Examples</b></p>
<pre>either a &lt; 0 [
   either a = 0 [
       msg: "zero"
   ][
       msg: "negative"
   ]
][
   msg: "positive"
]

print ["a is " msg lf]
</pre>
<p>An alternative way to write it (allowed because all code paths return a value of the same type):</p>
<pre>msg: either a &lt; 0 [
   either a = 0 [
       "zero"
   ][
       "negative"
   ]
 ][
   "positive"
]
prin ["a is " msg lf]
</pre>
</blockquote>
<h3 id="section-9.3">9.3 loop</h3>
<blockquote>
<p>Loop over a block of code, decrementing a counter down to zero. LOOP does not return any value, so it cannot be used in an expression.</p>
<p><b>Syntax</b></p>
<pre>loop &lt;counter&gt; [&lt;code&gt;]

&lt;counter&gt; : a valid expression returning a positive integer value
&lt;code&gt;    : code to execute while the condition is not met
</pre>
<p><b>Examples</b></p>
<pre>loop 3 [print "o"]
</pre>
<p>will output:</p>
<pre>ooo

a: 2
b: 3
loop a + b [print "o"]
</pre>
<p>will output:</p>
<pre>ooooo
</pre>
</blockquote>
<h3 id="section-9.4">9.4 until</h3>
<blockquote>
<p>Loop over a block of code until the condition at the end of the block, is met. UNTIL does not return any value, so it cannot be used in an expression.</p>
<p><b>Syntax</b></p>
<pre>until [
   &lt;code&gt;
   &lt;condition&gt;
]

&lt;code&gt;      : code to execute while the condition is not met
&lt;condition&gt; : a conditional expression
</pre>
<p><u>Note</u>: The loop will always be executed at least once, even if the condition is met from the beginning.</p>
<p><b>Example</b></p>
<pre>c: 5
until [
   print "o"
   c: c - 1
   c = 0
]
</pre>
<p>will output:</p>
<pre>ooooo
</pre>
</blockquote>
<h3 id="section-9.5">9.5 while</h3>
<blockquote>
<p>While a given condition is met, execute a block of code. WHILE does not return any value, so it cannot be used in an expression.</p>
<p><b>Syntax</b></p>
<pre>while [&lt;condition&gt;][&lt;code&gt;]

&lt;condition&gt; : a conditional expression
&lt;code&gt;      : code to execute if the condition is met
</pre>
<p><u>Note</u>: It is possible to execute any code in the condition block as long as it ends with a conditional expression.</p>
<p><b>Example</b></p>
<pre>c: 5
while [c &gt; 0][
   print "o"
   c: c - 1
]
</pre>
<p>will output:</p>
<pre>ooooo
</pre>
</blockquote>
<h3 id="section-9.6">9.6 break</h3>
<blockquote>
<p>BREAK allows to break out of the nearest enclosing loop at once and resume execution after the loop.</p>
<p><b>Syntax</b></p>
<pre>break
</pre>
<p><b>Example</b></p>
<pre>c: 5
until [
   print "o"
   break
   c: c - 1
   c = 0
]
</pre>
<p>will output:</p>
<pre>o
</pre>
</blockquote>
<h3 id="section-9.7">9.7 continue</h3>
<blockquote>
<p>CONTINUE skips the remaining part of a body loop and resume execution at next loop iteration.</p>
<p><b>Syntax</b></p>
<pre>continue
</pre>
<p><b>Example</b></p>
<pre>c: 5
until [
   print "o"
   c: c - 1
   either c &gt; 3 [continue][break]
   c = 0
]
</pre>
<p>will output:</p>
<pre>oo
</pre>
</blockquote>
<h3 id="section-9.8">9.8 any</h3>
<blockquote>
<p>Global condition is met if at least one of the sub-conditions is met. ANY returns a logic! value.</p>
<p><b>Syntax</b></p>
<pre>any [&lt;condition-1&gt; &lt;condition-2&gt; ...]

&lt;condition-*&gt; : a conditional expression
</pre>
<p><b>Example</b></p>
<pre>if any [foo &gt; 5 bar = 0][
   print "true"                    ;-- reached if at least one condition is met
]
</pre>
</blockquote>
<h3 id="section-9.9">9.9 all</h3>
<blockquote>
<p>Global condition is met if all the sub-conditions are met.  ALL returns a logic! value.</p>
<p><b>Syntax</b></p>
<pre>all [&lt;condition-1&gt; &lt;condition-2&gt; ...]

&lt;condition-*&gt; : a conditional expression
</pre>
<p><b>Example</b></p>
<pre>if all [foo &gt; 5 bar = 0][
   print "true"                    ;-- reached if both conditions are met
]
</pre>
</blockquote>
<h3 id="section-9.10">9.10 case</h3>
<blockquote>
<p>Execute the block of code following the first condition that is met. If all blocks of code end with an expression of same type, then CASE can be used inside an expression. A catch-all rule can be written using a conditional expression that always results in true.</p>
<p><u>Note</u>: if no value matches, a runtime error will be raised.</p>
<p><b>Syntax</b></p>
<pre>case [&lt;condition&gt; [&lt;body&gt;] ...]

&lt;condition&gt; : a conditional expression
&lt;body&gt;      : code to execute if the condition is met
</pre>
<p><b>Examples</b></p>
<pre>a: 3
case [
   zero? a [print "0"]
   a = 1   [print "1"]
   a &gt; 2   [print "greater than 2"]
]
</pre>
<p>will output:</p>
<pre>greater than 2
</pre>
<p>Example retrieving the returned value:</p>
<pre>time: 8
msg: case [
   all [6 &lt; time time &lt; 11]["morning"]
   all [11 &lt;= time time &lt; 22]["evening"]
   time &gt;= 22 ["night"]
]
print ["Good " msg]
</pre>
<p>will output:</p>
<pre>Good morning
</pre>
</blockquote>
<h3 id="section-9.11">9.11 switch</h3>
<blockquote>
<p>Execute the block of code following the first value matched, or the default block if present and no value matched. If all blocks of code end with an expression of same type, then SWITCH can be used inside an expression.</p>
<p><u>Note</u>: if no value matched and no default block is provided, a runtime error will be raised.</p>
<p><b>Syntax</b></p>
<pre>switch &lt;expression&gt; [&lt;values&gt; [&lt;body&gt;] ...]
switch &lt;expression&gt; [&lt;values&gt; [&lt;body&gt;] ... default [&lt;default-body&gt;]]

&lt;expression&gt;   : an expression resulting in byte! or integer! value
&lt;values&gt;       : one or several integer! or byte! literal values
&lt;body&gt;         : code to execute if one of the &lt;values&gt; is matched
&lt;default-body&gt; : code to execute if no value is matched
</pre>
<p><b>Examples</b></p>
<pre>a: 2
switch a [
   0 [print "green"]
   1 [print "orange"]
   2 [print "red"]
]
</pre>
<p>will output:</p>
<pre>red
</pre>
<p>Example using a default block:</p>
<pre>a: 3
switch a [
  0 [print "green"]
  1 [print "orange"]
  2 [print "red"]
  default [print "white"]
]
</pre>
<p>will output:</p>
<pre>white
</pre>
<p>Example retrieving the returned value:</p>
<pre>a: 2
year: switch a [
   0 [2010]
   1 [2011]
   2 [2012]
]
print ["Red will rock in " year]
</pre>
<p>will output:</p>
<pre>Red will rock in 2012
</pre>
<p>Example using multiple values for matching:</p>
<pre>input: 3
switch input [
   0 2 4 6 8 [print "even"]
   1 3 5 7 9 [print "odd"]
]
</pre>
<p>will output:</p>
<pre>odd
</pre>
</blockquote>
<h2 id="section-10">10. Exceptions</h2>
<blockquote>
<p>Exit and Return are sometimes not enough when it is needed to interrupt current execution and go back through several parent calls before resuming execution. Exceptions are solving such case by providing a way to resume execution from a parent caller anywhere in the calling hierarchy, up to global code level.</p>
</blockquote>
<h3 id="section-10.1">10.1 Throw</h3>
<blockquote>
<p>Raising a new exception is done by calling the <b>throw</b> function followed by an integer value used as the exception ID.</p>
<p><b>Syntax</b></p>
<pre>throw &lt;id&gt;

&lt;id&gt; : integer value used as exception ID
</pre>
<p><b>Throw</b> will produce an exception that will move up through the parent calls until:</p>
<ul>
<li>a <b>catch</b> statement is encountered and the exception filter value is greater or equal than the exception ID value.</li>
<li>a function with a <b>[catch]</b> attribute is found.</li>
</ul>
<p>If no <b>catch</b> is encountered, the exception, once reaching global code level, with exit the program with a <u>runtime error</u>.</p>
<p><u>Note</u>: if <b>throw</b> is used from a function that has the <b>catch</b> attribute, the exception will still be raised and go through parent calls. This way, when a function with a <b>[catch]</b> attribute catches an exception, it can re-<b>throw</b> it if required.</p>
<p></p><fieldset class="fset"><legend>No callbacks support</legend>
<p>The exception mechanism does not work across external calls, so a callback function must not use <b>throw</b>, else a crash will be the likely outcome. Nested exceptions are still possible as long as they are caught before the callback function returns.</p>
</fieldset>
</blockquote>
<h3 id="section-10.2">10.2 Catch</h3>
<blockquote>
<p>There are two ways to catch exceptions created using <b>throw</b>.</p>
<h4 id="section-10.2.1">10.2.1 Catch statement</h4>
<p><b>Syntax</b></p>
<pre>catch &lt;filter&gt; [&lt;body&gt;]

&lt;filter&gt; : integer value used to filter exceptions.
&lt;body&gt;   : arbitrary body of code to which this catch applies to.
</pre>
<p>An exception occuring in &lt;body&gt; block (including deeply nested ones that were uncaught) will be caught only if its ID value is less or equal than the &lt;filter&gt; value. Once an exception is being caught, the execution resumes after the <b>catch</b> body block.</p>
<p><u>Note</u>: Once an exception is caught by <b>catch</b>, the exception value can be retrieved using <b>system/thrown</b>.</p>
<p>Example in global context:</p>
<pre>catch 123 [
    print "hello"
    throw 10
    print "&lt;hidden&gt;"
]
print " world"
</pre>
<p>will output:</p>
<pre>hello world
</pre>
<p>Example using a nested exception:</p>
<pre>bar: does [
   print "hello"
   throw 123
   print "&lt;hidden&gt;"
]

foo: does [
   catch 5 [bar]                       ;-- exception 123 not catchable
   print "&lt;hidden&gt;"
]

catch 1000 [foo]                       ;-- exception will be caught here
</pre>
<p>will output:</p>
<pre>hello
</pre>
<h4 id="section-10.2.2">10.2.2 Catch attribute</h4>
<p><b>Syntax</b></p>
<pre>func [[catch]...][...]
</pre>
<p>A <b>[catch]</b> attribute will make the function catch all exceptions and resume at the next instruction. This attribute cannot be used in conjunction with other function attributes.</p>
<p></p><fieldset class="fset"><legend>Implementation note</legend>
<p>The internal threshold value for the [catch] attribute is set to FFFFFFFEh. The FFFFFFFFh value is defined as the CATCH_ALL macro and reserved for the internal catching sub-system at root level.</p>
</fieldset>
<p>Example:</p>
<pre>baz: does [
   print " "
   throw 123
   print "&lt;hidden&gt;"                    ;-- never executed
]
bar: does [
   print "hello"
   baz
   print "&lt;hidden&gt;"                    ;-- never executed
]
foo: func [[catch]][
   bar
   print "world"                       ;-- execution resumes there
]

foo
</pre>
<p>will output:</p>
<pre>hello world
</pre>
</blockquote>
<h3 id="section-10.3">10.3 Exception value</h3>
<blockquote>
<p>The integer argument passed to <b>throw</b> is propagated with the exception, it can be read using a system access path: <b>system/thrown</b></p>
<p><b>Syntax</b></p>
<pre>system/thrown                          ;-- read access (returns an integer)
system/thrown: &lt;id&gt;                    ;-- write access

&lt;id&gt; : integer value
</pre>
<p>The <b>system/thrown</b> path can be both read and written. It can be used to take different actions depending on the thrown value. The write access exists so that the value can be resetted manually when needed. It is recommended to reset it to 0 in such cases.</p>
<p><b>Examples</b></p>
<pre>foo                                    ;-- taken from previous example
print system/thrown
</pre>
<p>will output:</p>
<pre>123
</pre>
<p>A dispatching use case would look like this:</p>
<pre>foo: does [throw 10]
bar: does [throw 20]
baz: does [throw 30]

dispatch: func [[catch] n [integer!]][
   system/thrown: 0                    ;-- this is only useful if no exception occurs

   switch n [
       1 [foo]
       2 [bar]
       3 [baz]
       default [
           print-line "do nothing"
       ]
   ]
   switch system/thrown [
       0  [print "no exception occured"]
       10 [print "foo"]
       20 [print "bar"]
       30 [print "baz"]
   ]
]

dispatch 2
</pre>
<p>will output:</p>
<pre>bar
</pre>
</blockquote>
<h2 id="section-11">11. 栈函数</h2>
<blockquote>
</blockquote>
<h3 id="section-11.1">11.1 push</h3>
<blockquote>
<p>将一个值放入执行栈的栈顶，栈指针被修改。</p>
<p><b>语法</b></p>
<pre>push &lt;value&gt;

&lt;value&gt;: expression of any type
</pre>
<p><b>例子</b></p>
<pre>push 123
push a
push "hello"
push p/value
</pre>
</blockquote>
<h3 id="section-11.2">11.2 pop</h3>
<blockquote>
<p>从执行栈的栈顶弹出一个值，栈指针被修改。</p>
<p><b>语法</b></p>
<pre>pop

return: an integer value
</pre>
</blockquote>
<h2 id="section-12">12. 调试函数</h2>
<blockquote>
</blockquote>
<h3 id="section-12.1">12.1 assert</h3>
<blockquote>
<p>产生运行时断言。如果断言失败，运行时错误将会被抛出。</p>
<p><b>语法</b></p>
<pre>assert &lt;conditional expression&gt;
</pre>
<p><b>例子</b></p>
<pre>Red/System []

assert 1 = 2
</pre>
<p>保存代码到%test.reds文件然后运行，将会抛出：</p>
<pre>*** Runtime Error 98: assertion failed at line 3
*** in file: %test.reds
</pre>
<p></p><fieldset class="fset"><legend>编译器调试模式</legend>
<p>断言功能只有在<b>debug?</b>编译选项被设置为YES或者命令行指定了<b>-g</b>选项的情况下才会启用，否则的话，断言功能会被编译器忽略。</p>
</fieldset>
</blockquote>
<h2 id="section-13">13. 系统结构体</h2>
<blockquote>
<p>系统结构体是在运行时定义的一种特殊的结构体值，可以用来访问Red/System的一些核心特性。</p>
</blockquote>
<h3 id="section-13.1">13.1 args-count</h3>
<blockquote>
<p>得到命令行传递的参数个数。可执行文件自身也被计算在内，所以<b>args-count</b>总是大于等于1.</p>
<p><b>语法</b></p>
<pre>system/args-count

return: an integer value (&gt;= 1)
</pre>
</blockquote>
<h3 id="section-13.2">13.2 args-list</h3>
<blockquote>
<p>指向一个包含命令行参数的数组(包括程序自身)，数组的结尾用空指针(null pointer)标记。</p>
<p><b>语法</b></p>
<pre>system/args-list

return: a pointer value of type: str-array! (alias)
</pre>
<p>指针别名被定义为：</p>
<pre>str-array!: alias struct! [
   item [c-string!]
]
</pre>
<p><b>例子</b></p>
<pre>Red/System [purpose: "demo system/args-* info usage"]

print ["count: " system/args-count lf]
args: system/args-list 
c: 1 
until [ 
   print [c ": " args/item lf] 
   c: c + 1 
   args: args + 1 
   args/item = null 
]
</pre>
<p>如果将上面的代码编译为<i>show-args</i>可执行文件，然后运行：</p>
<pre>show-args 123 -p hello
</pre>
<p>将会输出：</p>
<pre>count: 4
1: show-args
2: 123
3: -p
4: hello
</pre>
</blockquote>
<h3 id="section-13.3">13.3 env-vars</h3>
<blockquote>
<p>指向一个包含SHELL环境变量和值的数组，数组的结尾用空指针(null pointer)标记。</p>
<p><b>语法</b></p>
<pre>system/env-vars

return: a pointer value of type: str-array! (alias)
</pre>
<p>指针的别名被定义为：</p>
<pre>str-array!: alias struct! [
   item [c-string!]
]
</pre>
<p><b>例子</b></p>
<pre>Red/System [purpose: "demo system/env-vars usage"]

env: system/env-vars 
until [ 
   print [env/item lf] 
   env: env + 1 
   env/item = null 
]
</pre>
<p>将会输出(依你的操作系统和SHELL而定)：</p>
<pre>ORBIT_SOCKETDIR=/tmp/orbit-root
SSH_AGENT_PID=2248
TERM=xterm
SHELL=/bin/bash
...                                ;-- rest of output omitted
</pre>
<p></p><fieldset class="fset"><legend>注意</legend>
<p>在Windows平台上，system/env-vars总是为null。这一点将来可能会改进。</p>
</fieldset>
</blockquote>
<h3 id="section-13.4">13.4 stack/top</h3>
<blockquote>
<p>设置或返回可执行栈的栈顶地址。</p>
<p><b>语法</b></p>
<p>获取栈顶地址：</p>
<pre>system/stack/top

return: a pointer value of type: pointer! [integer!]
</pre>
<p>设置栈顶地址：</p>
<pre>system/stack/top: &lt;address&gt;

&lt;address&gt;: a pointer value of type: pointer! [integer!]
</pre>
<p></p><fieldset class="fset"><legend>关于修改栈指针</legend>
<p>除非你知道修改所带来的结果，否则不要轻易修改栈指针。不然你的程序基本上运行会崩溃。</p>
</fieldset>
</blockquote>
<h3 id="section-13.5">13.5 stack/frame</h3>
<blockquote>
<p>设置或返回可执行栈的栈帧地址。</p>
<p><b>语法</b></p>
<p>获取栈帧地址：</p>
<pre>system/stack/frame

return: a pointer value of type: pointer! [integer!]
</pre>
<p>设置栈帧地址：</p>
<pre>system/stack/frame: &lt;address&gt;

&lt;address&gt;: a pointer value of type: pointer! [integer!]
</pre>
<p></p><fieldset class="fset"><legend>关于修改栈指针</legend>
<p>除非你知道修改所带来的结果，否则不要轻易修改栈指针。不然你的程序基本上运行会崩溃。</p>
</fieldset>
</blockquote>
<h3 id="section-13.6">13.6 stack/align</h3>
<blockquote>
<p>确保本地栈根据目标ABI要求对齐调用点。它返回一个新的、对齐后的栈指针。</p>
<p><b>语法</b></p>
<pre>system/stack/align

return: a pointer value of type: pointer! [integer!]
</pre>
</blockquote>
<h3 id="section-13.7">13.7 stack/allocate</h3>
<blockquote>
<p>在栈上(在栈槽单元内)保留一块存储区域，然后返回执行这块区域首地址的指针。它可以给本地栈上的数据结构分配任意的空间，这种空间在函数退出后会自动释放。</p>
<p><b>语法</b></p>
<pre>&lt;ptr&gt;: system/stack/allocate &lt;slots&gt;

&lt;ptr&gt;  : variable of type: pointer! [integer!]
&lt;slots&gt;: expression returning an integer
</pre>
<p></p><fieldset class="fset"><legend>栈槽单元</legend>
<p>栈槽单元依赖于系统架构，在IA-32和ARM上，一个单元等于4个字节。</p>
</fieldset>
</blockquote>
<h3 id="section-13.8">13.8 stack/free</h3>
<blockquote>
<p>释放栈上(在栈槽单元内)的一块存储区域。它可以用来手动控制对调用<i>system/stack/allocate</i>分配的存储空间的释放，或在函数外使用。</p>
<p><b>语法</b></p>
<pre>system/stack/free &lt;slots&gt;

&lt;slots&gt;: expression returning an integer
</pre>
<p></p><fieldset class="fset"><legend>手动操作栈和异常</legend>
<p>当前异常的实现(catch/throw)不能与手动操作的栈结合，因此在栈上分配的空间<b>必须</b>在进入<i>catch</i>块之前释放，或者使用<i>throw</i>关键字。</p>
</fieldset>
</blockquote>
<h3 id="section-13.9">13.9 pc</h3>
<blockquote>
<p>获取CPU程序计数器的值。</p>
<p><b>语法</b></p>
<pre>system/pc
</pre>
<p></p><fieldset class="fset"><legend>特定平台的结果</legend>
<p>IA-32架构会返回EIP寄存器的值。</p>
<p>ARM架构会返回PC(r15)寄存器的值。</p>
</fieldset>
</blockquote>
<h3 id="section-13.10">13.10 cpu</h3>
<blockquote>
<p>设置或返回CPU中任意一个寄存器的值。</p>
<p><b>语法</b></p>
<p>读取寄存器的值：</p>
<pre>system/cpu/&lt;register&gt;

return: a value of type integer!.
</pre>
<p>设置寄存器的值：</p>
<pre>system/cpu/&lt;register&gt;: &lt;value&gt;
</pre>
<p>补充：</p>
<pre>&lt;register&gt;: valid name of a CPU register (platform-dependent)
&lt;value&gt;   : an integer! value
</pre>
<p></p><fieldset class="fset"><legend>寄存器名称</legend>
<p>当前支持以下名称：</p>
<ul>
<li><b>IA-32</b>: eax, ecx, edx, ebx, esp, ebp, esi, edi</li>
<li><b>ARM</b>: r0 to r15</li>
</ul>
<p>将来会添加对更多寄存器访问的支持(比如状态寄存器)。</p>
</fieldset>
</blockquote>
<h3 id="section-13.11">13.11 cpu/overflow?</h3>
<blockquote>
<p>检查最后的整数算术操作是否溢出：</p>
<p><b>语法</b></p>
<pre>system/cpu/overflow?

return: a value of type logic!.
</pre>
<p>由于很多CPU操作可以改变这个状态，所以它仅仅在算术操作之后立即使用才有效。</p>
<p></p><fieldset class="fset"><legend>CPU溢出标志</legend>
<p>这个命令不是直接检查溢出标志，因为有些CPU的一些算术操作不会设置溢出标志。</p>
</fieldset>
</blockquote>
<h3 id="section-13.12">13.12 fpu/type</h3>
<blockquote>
<p>返回当前使用的FPU的唯一ID。</p>
<p><b>语法</b></p>
<pre>system/fpu/type
</pre>
<p>当前可能的返回值：</p>
<ul>
<li>FPU_TYPE_X87: for x87 FPU.</li>
<li>FPU_TYPE_SSE: for SSE unit on Intel.</li>
<li>FPU_TYPE_VFP: for ARM VFP unit.</li>
</ul>
</blockquote>
<h3 id="section-13.13">13.13 fpu/option</h3>
<blockquote>
<h4 id="section-13.13.1">13.13.1 fpu/option/rounding</h4>
<p>Set or retrieve the FPU rounding mode. The possible standard modes are:</p>
<ul>
<li>Nearest: (even) rounded result is the closest to the infinitely precise result</li>
<li>Down: (toward -INF) rounded result is the closest to but no greater than the infinitely precise result</li>
<li>Up: (toward +INF) rounded result is the closest to but no less than the infinitely precise result</li>
<li>Zero: (truncate) rounded result is the closest to but no greater in absolute value than the infinitely precise result</li>
</ul>
<p><b>Syntax</b></p>
<p>Reading a register:</p>
<pre>system/fpu/option/rounding
</pre>
<p>will return one of the following values:</p>
<p><b>Intel</b>:</p>
<ul>
<li>FPU_X87_ROUNDING_NEAREST</li>
<li>FPU_X87_ROUNDING_DOWN</li>
<li>FPU_X87_ROUNDING_UP</li>
<li>FPU_X87_ROUNDING_ZERO</li>
</ul>
<p><b>ARM</b>:</p>
<ul>
<li>FPU_VFP_ROUNDING_NEAREST</li>
<li>FPU_VFP_ROUNDING_DOWN</li>
<li>FPU_VFP_ROUNDING_UP</li>
<li>FPU_VFP_ROUNDING_ZERO</li>
</ul>
<p>Setting a register:</p>
<pre>system/fpu/option/rounding: &lt;value&gt;
</pre>
<p>where:</p>
<pre>&lt;value&gt;: is one of the valid values listed above.
</pre>
<h4 id="section-13.13.2">13.13.2 fpu/option/precision</h4>
<p><i><b>(Intel only)</b></i></p>
<p>Set or retrieve the FPU precision size.</p>
<p><b>Syntax</b></p>
<p>Reading a register:</p>
<pre>system/fpu/option/precision
</pre>
<p>will return one of the following values:</p>
<ul>
<li>FPU_X87_PRECISION_SINGLE       &nbsp;&nbsp;&nbsp;&nbsp;<i>(32-bit float, 24-bit mantissa)</i></li>
<li>FPU_X87_PRECISION_DOUBLE       &nbsp;&nbsp;&nbsp;&nbsp;<i>(64-bit float, 53-bit mantissa)</i></li>
<li>FPU_X87_PRECISION_DOUBLE_EXT   &nbsp;&nbsp;&nbsp;&nbsp;<i>(80-bit float, 64-bit mantissa)</i></li>
</ul>
<p>Setting a register:</p>
<pre>system/fpu/option/precision: &lt;value&gt;
</pre>
<p>where:</p>
<pre>&lt;value&gt;: is one of the valid values listed above.
</pre>
<h4 id="section-13.13.3">13.13.3 fpu/option/flush-to-zero</h4>
<p><i><b>(ARM only)</b></i></p>
<p>Enable or disable the Flush-to-zero mode. See ARM <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0274h/Babffifj.html">documentation</a> for more info.</p>
<p>Testing if flush mode is enabled:</p>
<pre>system/fpu/option/flush-to-zero

return: true (if mode is enable) | false
</pre>
<p>Enabling or disabling the flush mode:</p>
<pre>system/fpu/option/flush-to-zero: true | false
</pre>
<h4 id="section-13.13.4">13.13.4 fpu/option/NaN-mode</h4>
<p><i><b>(ARM only)</b></i></p>
<p>Enable or disable the default NaN mode. See ARM <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0274h/Babffifj.html">documentation</a> for more info.</p>
<p>Testing if default mode is enabled:</p>
<pre>system/fpu/option/NaN-mode

return: true (if mode is enable) | false
</pre>
<p>Enabling or disabling the default mode:</p>
<pre>system/fpu/option/NaN-mode: true | false
</pre>
</blockquote>
<h3 id="section-13.14">13.14 fpu/mask</h3>
<blockquote>
<p>设置FPU的异常掩码。以下异常有效：</p>
<ul>
<li>precision</li>
<li>underflow</li>
<li>overflow</li>
<li>zero-divide</li>
<li>denormal</li>
<li>invalid-op</li>
</ul>
<p><b>语法</b></p>
<p>读取异常掩码状态：</p>
<pre>system/fpu/mask/&lt;exception&gt;

return: true (exception is masked) | false
</pre>
<p>开启或关闭异常：</p>
<pre>system/fpu/mask/&lt;exception&gt;: &lt;value&gt;
</pre>
<p>补充：</p>
<pre>&lt;exception&gt; : is one of the above exception name
&lt;value&gt;     : an integer! value
</pre>
</blockquote>
<h3 id="section-13.15">13.15 fpu/control-word</h3>
<blockquote>
<p>设置或返回全部的FPU控制寄存器。</p>
<p><b>语法</b></p>
<p>读取控制值：</p>
<pre>system/fpu/control-word

return: a value of type integer!.
</pre>
<p>设置寄存器的值：</p>
<pre>system/fpu/control-word: &lt;value&gt;
</pre>
<p>补充：</p>
<pre>&lt;value&gt; : an integer! value
</pre>
<p></p><fieldset class="fset"><legend>ARM后端警告</legend>
<p>在ARM上设置control-word会产生副作用，因为相同的寄存器也被用于状态标识。</p>
</fieldset>
</blockquote>
<h3 id="section-13.16">13.16 fpu/epsilon</h3>
<blockquote>
<p><i>还没有实现。</i></p>
</blockquote>
<h3 id="section-13.17">13.17 fpu/update</h3>
<blockquote>
<p>使用最后设置的选项来高效的更新FPU。</p>
<p><b>语法</b></p>
<pre>system/fpu/update
</pre>
<p>应用到FPU的所有改变只有在这个命令被发送后才会生效。</p>
<p></p><fieldset class="fset"><legend>ARM后端</legend>
<p>在ARM后端上，改变会立即生效并且这个命令不做任何事，但是它对于写平台独立的代码还是很有用的。这些在将来也许会改进以便允许阶段性选项然后这个命令才会被启用。</p>
</fieldset>
</blockquote>
<h3 id="section-13.18">13.18 fpu/init</h3>
<blockquote>
<p>初始化FPU。</p>
<p><b>语法</b></p>
<pre>system/fpu/init
</pre>
<p></p><fieldset class="fset"><legend>仅Intel平台</legend>
<p>只有Intel平台需要，目前在ARM上这个指令没有任何效果。</p>
</fieldset>
</blockquote>
<h3 id="section-13.19">13.19 alias</h3>
<blockquote>
<p>获取一个别名的ID值。它在类型化函数(typed function)被用来区分不同的struct!值。</p>
<p><b>语法</b></p>
<pre>system/alias/&lt;name&gt;

where
   &lt;name&gt; : existing alias name
</pre>
<p>这个表达式返回一个<b>integer!</b>值，可以在运行时用于测试类型化函数(typed function)的参数类型。</p>
<p>例子：</p>
<pre>foo!: alias struct! [a [byte!]]
s: declare foo!

probe: func [
    [typed] count [integer!] list [typed-value!]
][
    until [
       if list/type = system/alias/foo! [
           print "foo! alias detected"
       ]
       list: list + 1
       count: count - 1
       zero? count
    ]
]

probe [1 "r" s 123]
</pre>
<p>将会输出：</p>
<pre>foo! alias detected
</pre>
</blockquote>
<h2 id="section-14">14. 编译器指令</h2>
<blockquote>
<p>Red/System的有些特性需要在编译时被处理而不是在运行时。这是一个把链接阶段和生成可执行文件关联起来的非常有用的一个特性。为了区别这些编译时命令或选项，这里对编译器指令作下介绍。它们的语法如下：</p>
<pre>#&lt;directive&gt; &lt;argument-1&gt; &lt;argument-2&gt; ...

&lt;directive&gt;  : a valid identifier
&lt;argument-*&gt; : argument can be any Red valid datatype
</pre>
<p>每个编译器指令后面，可以指定多个参数。</p>
<p>目前编译器指令只能作用在程序的全局部分，它们不能出现代码块的内部(如果将来增加了局部编译器指令，这个限制可能会被移除)。</p>
<p><u>注意</u>：这些指令可接受的参数的数据类型，是REBOL在启动阶段提供的类型之一。一旦Red层面完全实现，被允许的数据类型只能是Red中的数据类型。</p>
</blockquote>
<h2 id="section-15">15. Importing External Libraries</h2>
<blockquote>
</blockquote>
<h3 id="section-15.1">15.1 #import</h3>
<blockquote>
<p>Red/System is able to load external shared libraries at the time a Red/System executable is loaded by the operating system. This requires that the programmer gives instructions to the compiler about which library to load and how to map library's functions and variables to Red/System current context. This feature is called "library import" in Red/System and it is supported by a specific compiler directive: <b>#import</b>. This directive can be used anywhere in the global or local contexts of your Red/System program, but be sure to put it <i>before</i> you use one of the mapped functions, else a compiler error will be raised. This directive can be used multiple times in your source code if it makes it more readable. If there is a huge number of functions to imports, putting them in separate includes files would be considered as good practice.</p>
<p><u>Note</u>: this is not the same as dynamically loading a shared library from your Red/System code after your program has started. Such approach allows you to delay the loading of your libraries and to free them. Imports cannot be freed.</p>
<p><b>Syntax</b></p>
<pre>#import [
   "&lt;library&gt;" &lt;convention&gt; [
       &lt;function name&gt;: "&lt;ID&gt;" [
           &lt;argument&gt; [&lt;datatype&gt;]
           ...
           return: [&lt;datatype&gt;]        ;-- optional part
       ]
       ...                             ;-- more functions mappings
       &lt;variable name&gt;: "&lt;VAR&gt;" [
           &lt;datatype&gt;
       ]
       ...                             ;-- more variables mappings
   ]
   ...                                 ;-- more libraries to load
]

&lt;library&gt;       : shared library file name (with extension)
&lt;convention&gt;    : calling convention of the library (stdcall | cdecl)
&lt;function name&gt; : name of the mapped function in current context
&lt;variable name&gt; : name of the mapped variable in current context
&lt;ID&gt;            : identifier of the function in the shared library
&lt;VAR&gt;           : identifier of the variable in the shared library
&lt;argument&gt;      : function's argument indentifier
&lt;datatype&gt;      : integer! | byte! | pointer! [integer! | byte!] |
                  float! | float32! | c-string! | struct! [&lt;members&gt;] |
                  function! [&lt;spec&gt;]
</pre>
<p><u>Notes</u>:</p>
<ul>
<li>An absolute path to the library can be provided in OS-specific format.</li>
<li>The <b>RETURN:</b> statement indicates that the mapped function has a return value.</li>
<li>There's no limitation on the number of libraries or functions that can be declared this way.</li>
</ul>
<p>Supported calling conventions are:</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/X86_calling_conventions#stdcall" target="_new">stdcall</a>: used mostly by Windows API (but can be also used by third-party DLLs)</li>
<li><a href="http://en.wikipedia.org/wiki/X86_calling_conventions#cdecl" target="_new">cdecl</a>: default calling convention used by C shared libraries.</li>
</ul>
<p><b>Usage</b></p>
<p>The following example is Windows-specific.</p>
<pre>#import [
   "kernel32.dll" stdcall [
       process-id?: "GetCurrentProcessId" [
           return: [integer!]
       ]
       get-env: "GetEnvironmentVariableA" [
           name    [c-string!]
           buffer  [c-string!]
           size    [integer!]
           return: [integer!]
       ]
   ]
   "msvcrt.dll" cdecl [
       malloc: "malloc" [
           size    [integer!]
           return: [c-string!]
       ]
       release: "free" [
           block   [c-string!]
       ]
   ]
]

pid: process-id?

max-size: 128
buf: malloc  max-size                  ;-- allocate space for 127 characters

get-env "windir" buf  max-size

print buf
release buf
</pre>
<p>would output:</p>
<pre>C:\Windows
</pre>
</blockquote>
<h3 id="section-15.2">15.2 #syscall</h3>
<blockquote>
<p>As Red/System is destined to be used mostly for low-level system programming, <a href="http://en.wikipedia.org/wiki/System_call" target="_new">syscalls</a> mappings are also supported using the <b>#syscall</b> compiler directive.</p>
<p><b>Syntax</b></p>
<pre>#syscall [
   &lt;function name&gt;: &lt;ID&gt; [
       &lt;argument&gt; [&lt;datatype&gt;]
       ...
       return: [&lt;datatype&gt;]            ;-- optional part
   ]
   ...                                 ;-- more functions mappings
]
&lt;function name&gt; : name of the mapped function in global context
&lt;ID&gt;            : syscall integer ID
&lt;argument&gt;      : syscall's argument indentifier
&lt;datatype&gt;      : integer! | byte! | pointer! [integer! | byte!] |
                  float! | float32! | c-string! | struct! [&lt;members&gt;]
</pre>
<p>The <b>RETURN:</b> statement indicates that the mapped syscall has a return value.</p>
<p>There's no limitation on the number of syscalls that can be declared this way.</p>
<p><b>Usage</b></p>
<p>The following example is Linux-specific, but should work with most UNIX systems.</p>
<pre>#syscall [
   write: 4 [
       fd      [integer!]              ;-- file descriptor, STDOUT = 1
       buffer  [c-string!]
       count   [integer!]
       return: [integer!]
   ]
   quit: 1 [                           ;-- "exit" syscall, no return value
       status  [integer!]
   ]
]

msg: "Hello World"
result: write 1 msg length? msg
if negative? result [
   print "Error: write failed" 
   quit 3                              ;-- exit and return an error code
]
quit 0                                 ;-- no error
</pre>
<p>will output (if no error):</p>
<pre>Hello World
</pre>
</blockquote>
<h2 id="section-16">16. Source Processing</h2>
<blockquote>
<p>Red/System relies on a preprocessor to make compile-time modifications of the source code in order to provide syntactic sugars, like hexadecimal and character literal forms for integers. Some features are user controlled through compiler directives like <b>#define</b> or <b>#include</b>.</p>
</blockquote>
<h3 id="section-16.1">16.1 #define</h3>
<blockquote>
<p>The <b>#define</b> compiler directive is a rudimentary macro system that can be used to:</p>
<ul>
<li>define constant values</li>
<li>make simple macro expressions</li>
</ul>
<p>The name matching method is exact word matching. This ensures that no accidental source code corruption can occur.</p>
<p><b>Syntax</b></p>
<pre>#define &lt;name&gt; &lt;value&gt;

&lt;name&gt;  : identifier to use in the source code
&lt;value&gt; : single value or block of values to replace in the source code
</pre>
<p><b>Usage</b></p>
<pre>#define R_PART 00FF0000h               ;-- simple constants definitions
#define G_PART 0000FF00h
#define B_PART 000000FFh
#define zero?  [0 =]                   ;-- simple test expression macro

color: 00550063h

if zero? (R_PART and color) [
   print "Red not found"
]
if zero? (G_PART and color) [
   print "Green not found"
]
if zero? (B_PART and color) [
   print "Blue not found"
]
</pre>
<p>will output:</p>
<pre>Green not found
</pre>
<p><u>Note</u>: Parens are required in this example on test expressions so that the compiler performs the second infix expression (the and operator) before the first (the equal operator).</p>
<h4 id="section-16.1.1">16.1.1 Parametrized macros</h4>
<p>A more powerful macro version is possible, taking one or several parameters as input that get replaced in the emitted template.</p>
<p><b>Syntax (declaration)</b></p>
<pre>#define &lt;name&gt;(arg1 arg2 ...) &lt;body&gt;

&lt;name&gt; : macro identifier
&lt;body&gt; : macro body (block! or paren! value)
</pre>
<p><b>Syntax (usage)</b></p>
<pre>&lt;name&gt;(value1 value2 ...)
</pre>
<p>If the body is a block! value, its content replaces the name and parameters passed in the source code. If the body is a paren! value, the parens are kept after replacement in source code.</p>
<p><u>Notes</u>:</p>
<ul>
<li>The replacement process in the body block is done deeply in all series found, including paths.</li>
<li>Nested macros are fully supported.</li>
</ul>
<p>Examples:</p>
<pre>#define MAX(a b) (either a &gt; b [a][b])

print MAX(3 4)                         ;-- will print 4

#define SW(identifier) [system/words/identifier]

a: 123
print SW(a)                            ;-- will print 123
</pre>
<p></p><fieldset class="fset"><legend>Naming convention</legend>
<p>By convention, such parametrized macro names should be capitalized, so they can be more easily spotted in source code.</p>
</fieldset>
</blockquote>
<h3 id="section-16.2">16.2 #enum</h3>
<blockquote>
<p>The <b>#enum</b> compiler directive allows to declare enumerations using labels. A list of integers is assign to a list labels. These labels could then be used anywhere in the source code and will be converted to their integer value when needed by the compiler.</p>
<p><b>Syntax</b></p>
<pre>#enum &lt;name&gt;! [
   &lt;label&gt; | &lt;label&gt;: &lt;value&gt;
   ...
]

&lt;name&gt;!  : enumeration name (ending with a ! by convention)
&lt;label&gt;  : label to which an integer value is assigned to
&lt;label&gt;: : one or several label(s) set to a given integer value
&lt;value&gt;  : integer value
</pre>
<p>The enumeration starts from 0 by default. It is possible to assign a starting value using a label name with a ending colon, followed by an integer. It is also possible to assign several labels to the same value.</p>
<p><u>Notes:</u></p>
<ul>
<li>labels syntactic rules are the same as for variable identifiers.</li>
<li>enumeration names are pseudo-types that can be used in any local or global variable declaration in place of a real type.</li>
<li>labels can be used in place of integer variables or literal integer values.</li>
<li>ambiguous enum or label names that could conflict with other existing names will raise a compilation error.</li>
</ul>
<p><b>Examples</b></p>
<pre>#enum colors! [A B C D E]
print-wide [A E]
</pre>
<p>will output</p>
<pre>0 4
</pre>
<p>Using in place of literal integers:</p>
<pre>#enum colors! [red blue green yellow]

a: red

print switch a [
   red    ["Red"]
   blue   ["Blue"]
   yellow ["Yellow"]
]
</pre>
<p>will output</p>
<pre>Red
</pre>
<p>Defining labels with user-selected value:</p>
<pre>#enum values! [a: 1 b c d: e: 10]

print-wide [a b c d e]
</pre>
<p>will output</p>
<pre>1 2 3 10 10
</pre>
</blockquote>
<h3 id="section-16.3">16.3 #include</h3>
<blockquote>
<p>The <b>#include</b> compiler directive will insert the target source file at the current position in the calling source code.</p>
<p>This directive helps split the source code in several files, allowing for example, to put common functions or definitions in a single place and including them where required, across several source files or across different projects.</p>
<p><b>Syntax</b></p>
<pre>#include %&lt;file&gt;

&lt;file&gt; : relative or full path to a Red/System source file
</pre>
<p></p><fieldset class="fset"><legend>Filename format</legend>
<p>The filename must be written using the OS-independent <a href="http://www.rebol.com/docs/core23/rebolcore-12.html#section-2" target="_new">REBOL file! format</a>.</p>
</fieldset>
<p><b>Usage</b></p>
<p>Rewriting the example from <i>#define</i> section:</p>
<pre>definitions.reds file:

    #define R_PART 00FF0000h
    #define G_PART 0000FF00h
    #define B_PART 000000FFh
    #define zero?  [0 =]

    test-primary: func [
       color [integer!]
       mask  [integer!]
       msg   [c-string!]
    ][
       if zero? (color and mask) [
           print msg
       ]
    ]

main.reds file:

    #include %definitions.reds

    color: 00550063h

    test-primary color R_PART "no Red found"
    test-primary color G_PART "no Green found"
    test-primary color B_PART "no Blue found"
</pre>
</blockquote>
<h3 id="section-16.4">16.4 #if</h3>
<blockquote>
<p>The <b>#if</b> compiler directive goal is to allow conditional compilation based on a simple conditional expression limited to a few compilation options. If the expression result is TRUE, the following block of code is compiled.</p>
<p><b>Syntax</b></p>
<pre>#if &lt;option&gt; &lt;op&gt; &lt;value&gt; [
   &lt;body&gt;
]

&lt;option&gt; : compiler option name (case-insensitive)
&lt;op&gt;     : =, &lt;&gt;, &lt;, &gt;, &lt;= or &gt;=
&lt;value&gt;  : any value accepted by the property
&lt;body&gt;   : Red/System source code
</pre>
<p>Valid option names and allowed values are listed in %config.r file, in a comment section. For words value, both word! and lit-word! syntaxes will be accepted.</p>
<p><b>Example</b></p>
<pre>#if OS = 'Windows [
    print "Running on Windows"
]
</pre>
<p><u>Note</u>: if the argument is a word and not a value (like an integer! or a logic!), it needs to be prefixed with ' character to avoid being evaluated (as in normal REBOL expressions).</p>
</blockquote>
<h3 id="section-16.5">16.5 #either</h3>
<blockquote>
<p>The <b>#either</b> compiler directive allows conditional compilation based on a simple conditional expression limited to a few compilation options. If the expression result is TRUE, the first block of code is compiled, else the second one is compiled.</p>
<p><b>Syntax</b></p>
<pre>#either &lt;option&gt; &lt;op&gt; &lt;value&gt; [
   &lt;body-TRUE&gt;
][
   &lt;body-FALSE&gt;
]

&lt;option&gt; : compiler option name (case-insensitive)
&lt;op&gt;     : =, &lt;&gt;, &lt;, &gt;, &lt;= or &gt;=
&lt;value&gt;  : any value accepted by the property
&lt;body-*&gt; : Red/System source code
</pre>
<p>Valid option names and allowed values are listed in %config.r file, in a comment section. For words value, both word! and lit-word! syntaxes will be accepted.</p>
<p><b>Example</b></p>
<pre>#either OS = 'Windows [
    print "Running on Windows"
][
    print "Running probably on a UNIX platform"
]
</pre>
<p><u>Note</u>: if the argument is a word and not a value (like an integer! or a logic!), it needs to be prefixed with ' character to avoid being evaluated (as in normal REBOL expressions).</p>
</blockquote>
<h3 id="section-16.6">16.6 #switch</h3>
<blockquote>
<p>The <b>#switch</b> compiler directive allows to define several conditionally compiled block of codes, depending on the value of a compilation option. The block following the option name is searched for a matching value and the following block of code is compiled.</p>
<p><b>Syntax</b></p>
<pre>#switch &lt;option&gt; [
   &lt;value-1&gt; [
       &lt;body-1&gt;
    ]
   &lt;value-2&gt; [
       &lt;body-2&gt;
   ]
   ...
   #default [                          ;-- optional default clause
       &lt;body-N&gt;
   ]
]

&lt;option&gt;  : compiler option name (case-insensitive)
&lt;value-*&gt; : any value accepted by the property
&lt;body-*&gt;  : Red/System source code
</pre>
<p>Valid option names and allowed values are listed in %config.r file, in a comment section. For words value, both word! and lit-word! syntaxes will be accepted.</p>
<p><u>Note</u>: the #default clause is optional. If present, it acts as a default catch-all value if none other is matched.</p>
<p><b>Example</b></p>
<pre>#switch type [
    exe [print "Building an executable"]
    dll [print "Building a dynamically linked library"]
    obj [print "Building an object file"]
    lib [print "Building a statically linked library"]
]
</pre>
<p><u>Note</u>: if the argument is a word, it does not need to be prefixed with ' character in a #switch block.</p>
</blockquote>
<h3 id="section-16.7">16.7 #verbose</h3>
<blockquote>
<p>This directive allows to locally change or overwrite the verbosity compilation option.</p>
<p><b>Syntax</b></p>
<pre>#verbose &lt;level&gt;

&lt;level&gt; : integer value from 0 (no logs) to 11 (exhaustive logs).
</pre>
<p>It is mostly used for local debugging of the compilation process by framing the source lines to log between two #verbose directives.</p>
<p>Example:</p>
<pre>#verbose 9
print "hello"                          ;-- maximum logs emitted
#verbose 0
print "world"                          ;-- no logs emitted
</pre>
</blockquote>
<h3 id="section-16.8">16.8 #call</h3>
<blockquote>
<p>As a dialect of Red, Red/System can call back a Red-level function, passing arguments, using a compiler directive.</p>
<p><b>Syntax</b></p>
<pre>#call [&lt;Red-call&gt; &lt;arg1&gt;...&lt;argn&gt;]

&lt;Red-call&gt;      : a Red word, or path (for refinements), referring to a function! value.
&lt;arg1&gt;...&lt;argn&gt; : list of arguments.
</pre>
<p>The arguments should be passed as pointers to Red values of the expected type, except for integer! and logic! datatypes, that can be passed inlined, without requiring any boxing. When required, for pointer arguments, a simple type casting is allowed.</p>
<p>Once the Red function returns, the normal execution of Red/System code continues. The Red return value cannot be directly retrieved currently, but it should be accessible from Red arguments stack. The Red function <b>must</b> have all arguments typed, else a compilation error will occur.</p>
<p>When a path is used as the function call, it refers to the function name, followed by refinements. The eventual refinements arguments are then, expected to be provided, following the mandatory ones.</p>
<p><b>Example</b></p>
<pre>Red []

inc: func [n [integer!]][n + 1]

#system [
   #call [inc 123]
   int: as red-integer! stack/arguments
   print int/value                     ;-- will print 124
]
</pre>
<p></p><fieldset class="fset"><legend>Requires Red compiler</legend>
<p>The <b>#call</b> directive needs to be processed by the Red compiler, so it cannot be used in Red/System standalone applications. The legal places to use it are:</p>
<ul>
<li>a Red routine</li>
<li>in a #system directive</li>
<li>in a #system-global directive</li>
</ul>
</fieldset>
</blockquote>
<h3 id="section-16.9">16.9 #export</h3>
<blockquote>
<p>When generating a shared library, the Red/System toolchain needs to know which identifiers will be exposed to third-party users of the library. This is achieved using the <b>#export</b> compiler directive.</p>
<p><b>Syntax</b></p>
<pre>#export [&lt;symbols&gt;]
#export &lt;cconv&gt; [&lt;symbols&gt;]

&lt;symbols&gt; : one or several function or global variable name
&lt;cconv&gt;   : optional calling convention word (stdcall or cdecl)
</pre>
<p>One or several #export directives can be used in the same Red/System library code.</p>
</blockquote>
<h3 id="section-16.10">16.10 #u16</h3>
<blockquote>
<p>Converts a literal string to UTF-16LE format. The string is stored in memory in that new format with a terminal UTF-16 NUL character.</p>
<p><b>Syntax</b></p>
<pre>#u16 &lt;string&gt;

&lt;string&gt; : a literal c-string!
</pre>
<p>Only literal strings can be statically processed by this directive.</p>
</blockquote>
<h2 id="section-17">17. Source code organization</h2>
<blockquote>
</blockquote>
<h3 id="section-17.1">17.1 Source files suffix</h3>
<blockquote>
<p>The official Red/System source file suffix to use is: <b>.reds</b></p>
</blockquote>
<h3 id="section-17.2">17.2 Header</h3>
<blockquote>
<p>Red/System enforces the usage of a standard header for all sources (one of the great ideas in REBOL), to both identify a valid Red/System program and document it.</p>
<p><b>Syntax</b></p>
<p>A valid Red/System source file will need this header:</p>
<pre>Red/System [
 &lt;name&gt;: &lt;value&gt;
 ...                                   ;-- more attributes...
]

&lt;name&gt;  : valid identifier
&lt;value&gt; : any Red valid datatype
</pre>
<p>There is no minimum or maximum number of entries that a valid header can contain, so an empty block will also be valid (but bad practice).</p>
<p><u>Implementation note</u>: Header values types are the ones provided by REBOL during the bootstrapping phase only. Once the Red layer will be implemented, the allowed datatypes will be Red ones.</p>
<p>The attribute that you can specify are not limited, you can add whatever you want/need. Anyway, some attribute names are used by convention:</p>
<ul>
<li><b>Title</b>:  application title</li>
<li><b>Purpose</b>: short description of the application purpose</li>
<li><b>Author</b>: source code author name</li>
<li><b>File</b>: name of the source file</li>
<li><b>Version</b>: source code version (usually using a <a href="http://www.rebol.com/docs/core23/rebolcore-16.html#section-3.9" target="_new">tuple! literal</a>)</li>
<li><b>Date</b>: date of last version</li>
<li><b>Rights</b>: copyrights</li>
<li><b>License</b>: source license (URL or full text)</li>
<li><b>History</b>: source modifications history</li>
<li><b>Note(s)</b>: any special notice</li>
</ul>
<p><b>Example</b></p>
<pre>Red/System [
   Title:   "Red/System small demo app"
   Author:  "Nenad Rakocevic"
   File:    %hello.reds
   Rights:  "Copyright (C) 2011 Nenad Rakocevic. All rights reserved."
   License: "BSD-3 - https://github.com/dockimbel/Red/blob/master/COPYING"
]
</pre>
</blockquote>
<h3 id="section-17.3">17.3 Code flow layout</h3>
<blockquote>
<p>A typical Red/System program is a mix of function definitions and global code (meaning executable code that is not in a function). There is no concept of "main" function in Red/System. The only entry point is the beginning of the source code and the exit point is at the end of the source code, or at a QUIT call if encountered before.</p>
<p>Example:</p>
<pre>foo: 123
print "hello"

bar: func [a [integer!]][foo * 2]
foo-twice: bar foo

either foo &lt; 100 [
   print "less than 100"
][
   print "more than 100"
]

bye: func [][print "goodbye"]

bye
</pre>
<p>So, it is possible to mix functions and global code providing that functions are defined before they are called from global context. Such restrictions don't apply if the call is made from a function context, so cross-references like these:</p>
<pre>foo: func [...][...bar...]
bar: func [...][...foo...]
</pre>
<p>can be processed without issues.</p>
</blockquote>
<h3 id="section-17.4">17.4 Coding guidelines</h3>
<blockquote>
<p><i>TBD</i></p>
</blockquote>
<h3 id="section-17.5">17.5 Shared library program</h3>
<blockquote>
<p>You can use global code in your shared library program, but this is not recommended, as it might be unsupported in the future. All your code should be in functions.</p>
<p><u>Note</u>: All shared library programs need to export at least one symbol using the <b>#export</b> directive or a compilation error will occur.</p>
<p>A shared library might implement one or several of the callbacks below:</p>
<ul>
<li><b>on-load</b> : called when the library is loaded by the host</li>
<li><b>on-unload</b> : called when the library is freed by the host</li>
</ul>
<p>The specifications for these callbacks are system-specific:</p>
<p><b>Windows</b></p>
<pre>on-load:        func [hModule [integer!]][...]
on-unload:      func [hModule [integer!]][...]
on-new-thread:  func [hModule [integer!]][...] ;-- Windows-specific callback
on-exit-thread: func [hModule [integer!]][...] ;-- Windows-specific callback
</pre>
<p><b>MacOS X</b></p>
<pre>on-load: func [
   argc    [integer!]
   argv    [struct! [s [c-string!]]]
   envp    [struct! [s [c-string!]]]
   apple   [struct! [s [c-string!]]]
   pvars   [program-vars!]
][...]
on-unload: func [[cdecl]][...]
</pre>
<p><b>Others</b></p>
<pre>on-load:   func [][...]
on-unload: func [][...]
</pre>
</blockquote>
<h3 id="section-17.6">17.6 Driver program (experimental)</h3>
<blockquote>
<p>It is possible to generate kernel drivers with Red/System. The same remarks as for shared library programs apply to a driver program.</p>
<p>The driver entry point is a <b>on-load</b> function in Red/System that has the following specification:</p>
<pre>on-load: func [
   DriverObject [driver-object!]   ;-- predefined type (empty struct for now)
   RegistryPath [byte-ptr!]        ;-- Unicode string (UTF-16LE)
   return: [integer!]
][...]
</pre>
<p>A minimal Windows driver would look like:</p>
<pre>Red/System []

#enum NTSTATUS! [
   STATUS_SUCCESS
]

on-load: func [
   DriverObject [driver-object!]   ;-- predefined type (empty struct for now)
   RegistryPath [byte-ptr!]        ;-- Unicode string (UTF-16LE)
   return: [NTSTATUS!]
][
   STATUS_SUCCESS
]
</pre>
<p></p><fieldset class="fset"><legend>Experimental support</legend>
<p>Currently it is only supported on Windows platforms.</p>
</fieldset>
</blockquote>
<h2 id="section-18">18. 保留关键字</h2>
<blockquote>
<p>以下的符号和关键字都是被保留的，它们不能被用作变量名或函数名：</p>
<pre>%           &amp;           * 
+           -           -**
/           //          ///
&lt;           &lt;&lt;          &lt;= 
&lt;&gt;          =           &gt;
&gt;&gt;          &gt;=          &gt;&gt;&gt;
??          alias       all
and         any         as
assert      break       case
comment     context     continue
declare     either      exit
false       func        function
if          loop        not
null        or          pop
push        return      size?
switch      throw       true
until       use         while
with        xor
</pre>
<p></p><fieldset class="fset"><legend>启动约束</legend>
<p>-**(内部表示为&gt;&gt;&gt;)和///(内部表示为%)都是为了满足REBOL的词法扫描器的要求，一旦启动阶段完成，这些符号会自动从保留关键字列表中移除。</p>
</fieldset>
</blockquote>
<h2 id="section-19">19. Possible Evolutions</h2>
<blockquote>
</blockquote>
<h3 id="section-19.1">19.1 Variables</h3>
<blockquote>
<ul>
<li>Add support for multiple assignments, like a: b: c: 0</li>
</ul>
</blockquote>
<h3 id="section-19.2">19.2 Pointers</h3>
<blockquote>
<ul>
<li><strike>Remove pointer! datatype (struct! is able to do the same job)</strike> <i><b>REJECTED</b></i></li>
<li>Accept boolean operations on pointers: OR, XOR, AND (nice but use-cases would be rare?)</li>
</ul>
</blockquote>
<h3 id="section-19.3">19.3 Struct</h3>
<blockquote>
<ul>
<li>Add support for specifying struct memory alignment and padding. Default structure and members alignment would be the one specified in target object (per target). Per struct specific rules should be possible using the following syntax:</li>
</ul>
<pre>#align &lt;integer&gt;               ;-- change memory alignment for all subsequent
                               ;-- c-strings, pointers and structs.

struct [
   [align &lt;n&gt; &lt;little|big&gt;]    ;-- change members alignment and endianess
   &lt;members&gt;
]

&lt;n&gt;      : number of bytes to align members to
&lt;little&gt; : little endian (optional)
&lt;big&gt;    : big endian (optional)
</pre>
<ul>
<li><strike>Add support for passing struct! by value when required.</strike></li>
</ul>
</blockquote>
<h3 id="section-19.4">19.4 C-strings</h3>
<blockquote>
<ul>
<li>Add a FOREACH control flow function to traverse c-strings (or even array! values):
A simple way to traverse a c-string could be:</li>
</ul>
<pre>foo: "I am a c-string"
foreach c foo [prin c]
</pre>
<p>will output:</p>
<pre>I am a c-string
</pre>
</blockquote>
<h3 id="section-19.5">19.5 Logic!</h3>
<blockquote>
<ul>
<li>Add logic! support for OR, XOR, AND operators (if it provides any advantage over ANY/ALL).</li>
</ul>
</blockquote>
<h3 id="section-19.6">19.6 Integer!</h3>
<blockquote>
<ul>
<li>Bind the integer! type to int32! or int64! depending on the target platform. It needs some further investigations to determine if it can be a real advantage or not.</li>
</ul>
</blockquote>
<h3 id="section-19.7">19.7 Functions</h3>
<blockquote>
<ul>
<li>Add support for functions refinements (same as in REBOL)</li>
<li><strike>Infer functions return value datatype</strike></li>
<li>Accept an integer parameter for [catch] attribute to set manually the catching level (to avoid manual exception re-throwing).</li>
<li>Distinguish the behaviour of <b>function</b> from <b>func</b> to assume all set-words are locals (as in Red).</li>
</ul>
</blockquote>
<h3 id="section-19.8">19.8 New datatypes</h3>
<blockquote>
<ul>
<li><b>Array!</b>: this datatype would allow declaring arrays of values that could be accessed with an integer index (similar to C arrays). Redundancy with c-string! datatype would need to be considered. Here is a draft of possible syntax and usage:</li>
</ul>
<pre>---- C ------               --------- Red/System ----------
int p[20] = 0;              p: array [20 integer!]
p[4] = 123;                 p/4: 123
p[i] = 123;                 p/i: 123
</pre>
<ul>
<li><strike>Add a uint8! datatype</strike></li>
<li>Add a uint16! (or short!) datatype</li>
<li>Add a uint64! (or long!) datatype</li>
<li><strike><b>Binary!</b>: this datatype was reserved early in the compiler's datatypes list, but not implemented. Its purpose was just to provide literal input/output forms in hexadecimal for c-string values. A standalone datatype for such purpose might be avoidable, hence the delayed implementation.</strike> <i><b>REJECTED</b></i></li>
<li><strike><b>Logic!</b>: add a boolean datatype, so that booleans resulting from conditional expressions become first class citizens.</strike></li>
</ul>
</blockquote>
<h3 id="section-19.9">19.9 New functions</h3>
<blockquote>
<ul>
<li>Add a FORM function (convert any datatype to c-string!)</li>
<li><strike>Add a SWITCH function: branch on different code blocks depending on a input value</strike></li>
<li>Add a INLINE function to inline machine code: inline #{1234...} and/or assembler</li>
<li><strike>Add a NOT function that would return the boolean opposite of argument value. As booleans are not really supported in the current specs, NOT addition is postponed.</strike></li>
<li>Add a REPEAT function to be able to loop with a counter:</li>
</ul>
<pre>total: 0
repeat c 10 [total: total + c]
</pre>
<ul>
<li>Add a TYPE? function returning the argument's type as integer! (should use defines to name them)</li>
</ul>
</blockquote>
<h3 id="section-19.10">19.10 Misc</h3>
<blockquote>
<ul>
<li>Add a module system (per-file contexts for example)</li>
<li><strike>Support 0 and 1 as valid boolean results</strike> <i><b>REJECTED</b></i></li>
<li><strike>Extend the get-word! syntax to integer! variables.</strike></li>
<li>Support multiple nested type castings.</li>
</ul>
</blockquote>
<h2 id="section-20">20. Document History</h2>
<blockquote>
<ul>
<li><b>01/05/2017 - revision 52</b></li>
<ul>
<li>Adds description of nested structs values.</li>
<li>Adds stack/allocate and stack/free sections.</li>
</ul>
<li><b>20/04/2017 - revision 51</b></li>
<ul>
<li>Adds description of structs by value passing/returning.</li>
<li>Adds USE keyword description.</li>
</ul>
<li><b>31/03/2017 - revision 50</b></li>
<ul>
<li>Adds description of get-path to get struct member address.</li>
</ul>
<li><b>29/03/2017 - revision 49</b></li>
<ul>
<li>Adds description for variables importing from external libraries.</li>
<li>Updates #call description to include refinements.</li>
<li>Adds a section for `size?` description.</li>
</ul>
<li><b>11/03/2017 - revision 48</b></li>
<ul>
<li>Additional explanations for `callback` attribute usage.</li>
</ul>
<li><b>10/10/2016 - revision 47</b></li>
<ul>
<li>Allows integer to floats, and floats to integer direct type casting (using FPU for conversions).</li>
<li>Adds description of system/cpu/overflow? accessor.</li>
<li>Minor improvement of type casting matrix, "to" removed to avoid confusion.</li>
</ul>
<li><b>09/03/2016 - revision 46</b></li>
<ul>
<li>Added #u16 directive description.</li>
</ul>
<li><b>12/05/2015 - revision 45</b></li>
<ul>
<li>Added BREAK and CONTINUE descriptions.</li>
<li>Added LOOP description.</li>
<li>Updated keywords section.</li>
</ul>
<li><b>13/03/2015 - revision 44</b></li>
<ul>
<li>Move exceptions description to its own separate section and upgraded it with the new CATCH statement description.</li>
<li>Fixed C void pointer bad code example</li>
</ul>
<li><b>13/10/2014 - revision 43</b></li>
<ul>
<li>Added notes about the possible future distinction between <b>function</b> and <b>func</b>.</li>
<li>Fixed 2 misleading statements about whether or not the condition is met in <b>until</b>.</li>
<li>Minor grammar cleanups.</li>
</ul>
<li><b>29/07/2014 - revision 42</b></li>
<ul>
<li>Removed the note about ELF backend not calling on-load/on-unload.</li>
<li>Added system/cpu et system/fpu sections.</li>
</ul>
<li><b>26/04/2014 - revision 41</b></li>
<ul>
<li>Added literal arrays section.</li>
<li>Type matrix adjustments on AS/TO meaning</li>
</ul>
<li><b>14/02/2014 - revision 40</b></li>
<ul>
<li>Function! to function! type casting now allowed.</li>
</ul>
<li><b>09/08/2013 - revision 39</b></li>
<ul>
<li>Extended function! pointer description to struct members. Updated type casting matrix accordingly.</li>
<li>Added function! as valid struct member.</li>
<li>Added back the <b>callback</b> attribut description.</li>
<li>Added <b>custom</b> attribut description.</li>
<li>Added <b>system/stack/align</b> description.</li>
<li>Added <b>#call</b> compiler directive description.</li>
<li>Added <b>#export</b> compiler directive description.</li>
<li>Added shared library and driver programs layouts sections.</li>
</ul>
<li><b>18/04/2013 - revision 38</b></li>
<ul>
<li>Added "Exceptions" section.</li>
<li>Added "Catch" attribute entry in "Attributes" section.</li>
<li>Added "throw" to keywords list.</li>
</ul>
<li><b>24/11/2012 - revision 37</b></li>
<ul>
<li>Issue #280 fixed (missing function! as possible target in type casting matrix)</li>
<li>Issue #283 fixed (uint8! mentions removed from document, only kept as possible evolutions)</li>
<li>Issue #286 fixed (missing `null` keyword in reserved keywords list)</li>
<li>Changed precedence order in WITH namespaces list</li>
<li>Changed description of modulo/remainder for floats, now they give the same result.</li>
</ul>
<li><b>24/10/2012 - revision 36</b></li>
<ul>
<li>Added docstrings in function syntax.</li>
<li>NULL type ID note added.</li>
<li>Added Function pointers alias and dereferencing descriptions.</li>
<li>Added parametrized macros description.</li>
<li>Added #verbose directive description.</li>
</ul>
<li><b>24/08/2012 - revision 35</b></li>
<ul>
<li>Added namespaces description</li>
<li>Added CONTEXT and WITH to keywords list.</li>
<li>Improved pointer! declaration description (section 4.8.2)</li>
<li>Added mention of first-class nature of datatypes.</li>
</ul>
<li><b>25/07/2012 - revision 34</b></li>
<ul>
<li>Added description for variable pointer (get-word extended).</li>
<li>Removed items already implemented from "Possible Evolutions" section.</li>
</ul>
<li><b>26/02/2012 - revision 33</b></li>
<ul>
<li>Removed misleading float32! syntax description and replaced by a simple explanation on how to form float32! literal values.</li>
<li>Fixed code example in section 4.4.2, the `as float32!` type casting was missing.</li>
</ul>
<li><b>04/02/2012 - revision 32</b></li>
<ul>
<li>Added float! and float32! datatypes.</li>
<li>Type casting matrix updated with float! and float32!</li>
<li>Updated list of runtime type IDs.</li>
<li>Added #enum description</li>
</ul>
<li><b>03/01/2012 - revision 31</b></li>
<ul>
<li>Completed CASE description</li>
<li>Added SWITCH description</li>
<li>Added SWITCH to keywords list</li>
<li>Changed the casing of the function names used as section headers.</li>
</ul>
<li><b>29/12/2011 - revision 30</b></li>
<ul>
<li>Added CASE description.</li>
<li>Update keywords list.</li>
<li>Minor typo fixed.</li>
<li>"API Reference" level removed, all sub-sections are moved up and placed after "Scoping" chapter.</li>
<li>Literal struct members default zero value mention added.</li>
</ul>
<li><b>21/09/2011 - revision 29</b></li>
<ul>
<li>Added description for system/alias/... special path.</li>
</ul>
<li><b>20/09/2011 - revision 28</b></li>
<ul>
<li>Typed attribute ID values and macros updated.</li>
<li>Callback attribute removed and replaced by 'cdecl attribute.</li>
</ul>
<li><b>17/09/2011 - revision 27</b></li>
<ul>
<li>Added missing bitshift operators in reserved keywords list.</li>
<li>Improve variadic function names in examples to avoid confusion with C function names.</li>
</ul>
<li><b>01/09/2011 - revision 26</b></li>
<ul>
<li>Added system/pc description.</li>
</ul>
<li><b>12/08/2011 - revision 25</b></li>
<ul>
<li>Fixed invalid hex values in some code examples.</li>
<li>Minor code example improvement for typed attributes.</li>
<li>Minor editing changes</li>
<li>Updated examples to use variadic print function</li>
</ul>
<li><b>09/08/2011 - revision 24</b></li>
<ul>
<li>Typeinfo function attribute renamed to typed.</li>
<li>Added a note about imported library path format.</li>
<li>Special 'system structure fully documented</li>
<li>Added push and pop as reserved keywords</li>
</ul>
<li><b>08/08/2011 - revision 23</b></li>
<ul>
<li>Variadic and typeinfo function attributes added.</li>
<li>Get-stack and set-stack functions removed.</li>
<li>Added system/stack/* descriptions.</li>
</ul>
<li><b>04/08/2011 - revision 22</b></li>
<ul>
<li>Stack manipulation functions added.</li>
</ul>
<li><b>24/07/2011 - revision 21</b></li>
<ul>
<li>Pointers arithmetic extended to allow addition and subtraction of pointer arguments.</li>
</ul>
<li><b>07/07/2011 - revision 20</b></li>
<ul>
<li>Added ASSERT keyword description</li>
</ul>
<li><b>05/07/2011 - draft 19</b></li>
<ul>
<li>Fixed #if and #either examples. Note added about lit-words arguments</li>
<li>Delimiters and free-form syntax descriptions added</li>
<li>Various small fixes and cleanups</li>
</ul>
<li><b>04/07/2011 - draft 18</b></li>
<ul>
<li>Added a note about alias names living in their own namespace.</li>
<li>Added % operator and notes to help distinguish % and // operators.</li>
<li>Added a mention for global variables initialization restriction in Null description.</li>
<li>Added -**, &gt;&gt;&gt;, %, /// in reserved keywords list.</li>
<li>Added bitshift operators section.</li>
<li>Propagated "struct" and "pointer" replacement by "declare <type>"</type></li>
</ul>
<li><b>23/06/2011 - draft 17</b></li>
<ul>
<li>Updated type casting description to match the new relaxed syntax implemented.</li>
<li>Added null keyword description.</li>
<li>Upgraded pointer! type reference to take byte! into account</li>
<li>C void pointers now mapped to pointer! [byte!] and byte-ptr!</li>
</ul>
<li><b>22/06/2011 - draft 16</b></li>
<ul>
<li>Added missing 'comment word in keywords list</li>
<li>Added variable initialization at root level restriction description.</li>
<li>Note added to warn about transparent statements after a function ending expression.</li>
<li>Minor code example cleanup (local type declaration removed)</li>
<li>Added a function! column in the type casting matrix.</li>
<li>Added missing Expression chapter.</li>
</ul>
<li><b>12/06/2011 - draft 15</b></li>
<ul>
<li>Added #either directive</li>
<li>#if and #either now accept any comparison operator</li>
</ul>
<li><b>11/06/2011 - draft 14</b></li>
<ul>
<li>Added #if and #switch directives description</li>
</ul>
<li><b>07/06/2011 - draft 13</b></li>
<ul>
<li>Keywords list updated, only symbols and keywords built in the compiler are retained.</li>
<li>Function pointer description and example updated wrt recent implementation changes.</li>
<li>Added &amp; as a reserved keyword (for future use)</li>
<li>Keyword list updated and cleaned up</li>
<li>Fixed non-confirming hex literals in examples (thanks Kaj)</li>
<li>Minor fixes</li>
</ul>
<li><b>05/06/2011 - draft 12</b></li>
<ul>
<li>Callback description rewrote entirely to match the new behaviour.</li>
<li>Function! type added to imported functions specification rules</li>
</ul>
<li><b>04/06/2011 - draft 11</b></li>
<ul>
<li>Multi-line comments restriction added.</li>
<li>Compiler directives usage inside code blocks is now forbidden explicitly.</li>
<li>Multiple type castings explicitly forbidden and added as possible evolution.</li>
<li>Type inference for return value removed.</li>
<li>Added new function attribute: callback</li>
</ul>
<li><b>23/05/2011 - draft 10</b></li>
<ul>
<li>Added type casting combinations matrix</li>
<li>Fixed uncomplete code example for ALIAS (thanks to Kaj)</li>
<li>Fixed list of allowed characters in variables (<a href="https://github.com/dockimbel/Red/issues/48">issue #48</a>)</li>
<li>Minor other fixes</li>
</ul>
<li><b>20/05/2011 - draft 9</b></li>
<ul>
<li>Added missing type casting syntax description for compound types (thanks to Andreas).</li>
</ul>
<li><b>19/05/2011 - draft 8</b></li>
<ul>
<li>Added logic! datatype to struct members and type casting allowed types.</li>
<li>Added a note about evaluation rule for user-defined infix functions.</li>
<li>Added missing types supporting math and comparison operations.</li>
<li>Explained condition permitting that EITHER function be used inside expression.</li>
<li>Mention about not possible inclusion in expressions for IF, UNTIL, WHILE.</li>
<li>Returned type for ANY and ALL precised.</li>
</ul>
<li><b>05/05/2011 - draft 7</b></li>
<ul>
<li>Removed mentions for c-string variables acting as constants.</li>
</ul>
<li><b>27/04/2011 - draft 6</b></li>
<ul>
<li>Added 'infix attribute support in functions spec block.</li>
<li>Added missing logic! datatype in functions spec block definition.</li>
</ul>
<li><b>15/04/2011 - draft 5</b></li>
<ul>
<li>Letters in hex integers are restricted to uppercase only. Warning added for variable names that could be mistaken for hex integers.</li>
<li>Logic! support for OR, XOR, AND operators withdrawn from specifications and put in the "Possible Evolution" section. (They can be replaced by ANY/ALL/NOT to compose logic expressions)</li>
<li>'Comment added as reserved keyword</li>
<li>Added a note for = and &lt;&gt; operators for use with logic! values. C-string! values comparisons restricted to those two operators only (c-string! was wrongly allowed for all comparison operators).</li>
</ul>
<li><b>10/04/2011 - draft 4</b></li>
<ul>
<li>Struct arguments are passed by reference now again. STRUCT returns a reference to the struct value.</li>
<li>Syntax now precised for STRUCT keyword followed by an alias name</li>
<li>Struct! arithmetic added</li>
<li>C-string! arithmetic added</li>
<li>Pointer! now restricted to [integer!] only. It is more consistent with c-string! and struct! which are both (implicit) pointers already.</li>
<li>Pointer! section moved after c-string! and struct! (because it is less important now)</li>
</ul>
<li><b>08/04/2011 - draft 3</b></li>
<ul>
<li>Added get-word! syntax for getting struct variable address</li>
<li>New Possible Evolution: extend get-word! syntax to all variable types</li>
<li>Added "pointer" as reserved keyword</li>
<li>Renamed "alias-type" keyword to "alias"</li>
<li>Byte! added to <datatypes> definitions</datatypes></li>
<li>Pointer syntax and declaration improved and extended to support paths with indexes</li>
<li>String! type renamed to c-string!</li>
<li>C-string path accesses now uses byte! values for reading and writing</li>
<li>Added type inference for functions local variables and return value</li>
<li>Function address can be returned using get-word! syntax</li>
<li>New "Nested functions" section added to be completed later</li>
<li>Added byte! datatype, character specific syntax moved from integer! to byte!</li>
<li>Added logic! datatype (boolean values)</li>
<li>Added TRUE and FALSE keywords</li>
<li>Added NOT operator</li>
<li>Old "Logical" operators renamed to the more appropriate "Bitwise" operators</li>
<li>Bitwise ops completed with boolean counterparts</li>
<li>More accurate syntax description for all infix operators</li>
<li>Functions local variables type is now optional if the variables are properly initialized</li>
<li>Added an empty "Type Conversion" to be completed later</li>
<li>Removed functions and macros defined in runtime from keywords, they can be redefined by user code if required</li>
<li>New Possible Evolution: integer! as a platform-specific type</li>
<li>Minor corrections and additions</li>
</ul>
<li><b>29/03/2011 - draft 2</b></li>
<ul>
<li>Added missing array! datatype proposition in Evolutions</li>
<li>Added missing EXIT and RETURN in reserved keywords list</li>
</ul>
<li><b>28/03/2011 - draft 1</b></li>
<ul>
<li>First public release</li>
</ul>
</ul>
</blockquote>
</td></tr><tr>
<td align="center">
<span class="tail">
	<a href="http://www.rebol.com/">MakeDoc2 by REBOL</a> - 16-Jul-2017
</span>
</td></tr></tbody></table>
</body></html>